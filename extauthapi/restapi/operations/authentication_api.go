// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"net/http"
	"strings"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/loads"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/runtime/middleware"
	"github.com/go-openapi/runtime/security"
	"github.com/go-openapi/spec"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// NewAuthenticationAPI creates a new Authentication instance
func NewAuthenticationAPI(spec *loads.Document) *AuthenticationAPI {
	return &AuthenticationAPI{
		handlers:            make(map[string]map[string]http.Handler),
		formats:             strfmt.Default,
		defaultConsumes:     "application/json",
		defaultProduces:     "application/json",
		customConsumers:     make(map[string]runtime.Consumer),
		customProducers:     make(map[string]runtime.Producer),
		PreServerShutdown:   func() {},
		ServerShutdown:      func() {},
		spec:                spec,
		useSwaggerUI:        false,
		ServeError:          errors.ServeError,
		BasicAuthenticator:  security.BasicAuth,
		APIKeyAuthenticator: security.APIKeyAuth,
		BearerAuthenticator: security.BearerAuth,

		JSONConsumer: runtime.JSONConsumer(),

		JSONProducer: runtime.JSONProducer(),

		ChangePasswordHandler: ChangePasswordHandlerFunc(func(params ChangePasswordParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation ChangePassword has not yet been implemented")
		}),
		DeleteUserHandler: DeleteUserHandlerFunc(func(params DeleteUserParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation DeleteUser has not yet been implemented")
		}),
		GetUserProfileHandler: GetUserProfileHandlerFunc(func(params GetUserProfileParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation GetUserProfile has not yet been implemented")
		}),
		GetUserProfileByIDHandler: GetUserProfileByIDHandlerFunc(func(params GetUserProfileByIDParams) middleware.Responder {
			return middleware.NotImplemented("operation GetUserProfileByID has not yet been implemented")
		}),
		IsEmailAvailableHandler: IsEmailAvailableHandlerFunc(func(params IsEmailAvailableParams) middleware.Responder {
			return middleware.NotImplemented("operation IsEmailAvailable has not yet been implemented")
		}),
		IsUsernameAvailableHandler: IsUsernameAvailableHandlerFunc(func(params IsUsernameAvailableParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation IsUsernameAvailable has not yet been implemented")
		}),
		LoginHandler: LoginHandlerFunc(func(params LoginParams) middleware.Responder {
			return middleware.NotImplemented("operation Login has not yet been implemented")
		}),
		LogoutHandler: LogoutHandlerFunc(func(params LogoutParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation Logout has not yet been implemented")
		}),
		RegisterHandler: RegisterHandlerFunc(func(params RegisterParams) middleware.Responder {
			return middleware.NotImplemented("operation Register has not yet been implemented")
		}),
		RegisterLoginOAuthHandler: RegisterLoginOAuthHandlerFunc(func(params RegisterLoginOAuthParams) middleware.Responder {
			return middleware.NotImplemented("operation RegisterLoginOAuth has not yet been implemented")
		}),
		ResetPasswordHandler: ResetPasswordHandlerFunc(func(params ResetPasswordParams) middleware.Responder {
			return middleware.NotImplemented("operation ResetPassword has not yet been implemented")
		}),
		SearchUsersByUsernameHandler: SearchUsersByUsernameHandlerFunc(func(params SearchUsersByUsernameParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation SearchUsersByUsername has not yet been implemented")
		}),
		SetBlockedHandler: SetBlockedHandlerFunc(func(params SetBlockedParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation SetBlocked has not yet been implemented")
		}),
		SetEmailHandler: SetEmailHandlerFunc(func(params SetEmailParams) middleware.Responder {
			return middleware.NotImplemented("operation SetEmail has not yet been implemented")
		}),
		SetNewPasswordHandler: SetNewPasswordHandlerFunc(func(params SetNewPasswordParams) middleware.Responder {
			return middleware.NotImplemented("operation SetNewPassword has not yet been implemented")
		}),
		SetPersDataRegionHandler: SetPersDataRegionHandlerFunc(func(params SetPersDataRegionParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation SetPersDataRegion has not yet been implemented")
		}),
		SetUsernameHandler: SetUsernameHandlerFunc(func(params SetUsernameParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation SetUsername has not yet been implemented")
		}),
		ValidateNewEmailHandler: ValidateNewEmailHandlerFunc(func(params ValidateNewEmailParams, principal interface{}) middleware.Responder {
			return middleware.NotImplemented("operation ValidateNewEmail has not yet been implemented")
		}),
		ValidateRegistrationEmailHandler: ValidateRegistrationEmailHandlerFunc(func(params ValidateRegistrationEmailParams) middleware.Responder {
			return middleware.NotImplemented("operation ValidateRegistrationEmail has not yet been implemented")
		}),

		// Applies when the "Cookie" header is set
		CookieKeyAuth: func(token string) (interface{}, error) {
			return nil, errors.NotImplemented("api key auth (cookieKey) Cookie from header param [Cookie] has not yet been implemented")
		},
		// Applies when the "X-CSRFTokenBound" header is set
		CsrfTokenAuth: func(token string) (interface{}, error) {
			return nil, errors.NotImplemented("api key auth (csrfToken) X-CSRFTokenBound from header param [X-CSRFTokenBound] has not yet been implemented")
		},
		// default authorizer is authorized meaning no requests are blocked
		APIAuthorizer: security.Authorized(),
	}
}

/*AuthenticationAPI ## List of all custom errors
First number is HTTP Status code, second is value of "code" field in returned JSON object, text description may or may not match "message" field in returned JSON object.
- 409.100: email is not available
- 404.101: invalid credentials
*/
type AuthenticationAPI struct {
	spec            *loads.Document
	context         *middleware.Context
	handlers        map[string]map[string]http.Handler
	formats         strfmt.Registry
	customConsumers map[string]runtime.Consumer
	customProducers map[string]runtime.Producer
	defaultConsumes string
	defaultProduces string
	Middleware      func(middleware.Builder) http.Handler
	useSwaggerUI    bool

	// BasicAuthenticator generates a runtime.Authenticator from the supplied basic auth function.
	// It has a default implementation in the security package, however you can replace it for your particular usage.
	BasicAuthenticator func(security.UserPassAuthentication) runtime.Authenticator
	// APIKeyAuthenticator generates a runtime.Authenticator from the supplied token auth function.
	// It has a default implementation in the security package, however you can replace it for your particular usage.
	APIKeyAuthenticator func(string, string, security.TokenAuthentication) runtime.Authenticator
	// BearerAuthenticator generates a runtime.Authenticator from the supplied bearer token auth function.
	// It has a default implementation in the security package, however you can replace it for your particular usage.
	BearerAuthenticator func(string, security.ScopedTokenAuthentication) runtime.Authenticator

	// JSONConsumer registers a consumer for the following mime types:
	//   - application/json
	JSONConsumer runtime.Consumer

	// JSONProducer registers a producer for the following mime types:
	//   - application/json
	JSONProducer runtime.Producer

	// CookieKeyAuth registers a function that takes a token and returns a principal
	// it performs authentication based on an api key Cookie provided in the header
	CookieKeyAuth func(string) (interface{}, error)

	// CsrfTokenAuth registers a function that takes a token and returns a principal
	// it performs authentication based on an api key X-CSRFTokenBound provided in the header
	CsrfTokenAuth func(string) (interface{}, error)

	// APIAuthorizer provides access control (ACL/RBAC/ABAC) by providing access to the request and authenticated principal
	APIAuthorizer runtime.Authorizer

	// ChangePasswordHandler sets the operation handler for the change password operation
	ChangePasswordHandler ChangePasswordHandler
	// DeleteUserHandler sets the operation handler for the delete user operation
	DeleteUserHandler DeleteUserHandler
	// GetUserProfileHandler sets the operation handler for the get user profile operation
	GetUserProfileHandler GetUserProfileHandler
	// GetUserProfileByIDHandler sets the operation handler for the get user profile by ID operation
	GetUserProfileByIDHandler GetUserProfileByIDHandler
	// IsEmailAvailableHandler sets the operation handler for the is email available operation
	IsEmailAvailableHandler IsEmailAvailableHandler
	// IsUsernameAvailableHandler sets the operation handler for the is username available operation
	IsUsernameAvailableHandler IsUsernameAvailableHandler
	// LoginHandler sets the operation handler for the login operation
	LoginHandler LoginHandler
	// LogoutHandler sets the operation handler for the logout operation
	LogoutHandler LogoutHandler
	// RegisterHandler sets the operation handler for the register operation
	RegisterHandler RegisterHandler
	// RegisterLoginOAuthHandler sets the operation handler for the register login o auth operation
	RegisterLoginOAuthHandler RegisterLoginOAuthHandler
	// ResetPasswordHandler sets the operation handler for the reset password operation
	ResetPasswordHandler ResetPasswordHandler
	// SearchUsersByUsernameHandler sets the operation handler for the search users by username operation
	SearchUsersByUsernameHandler SearchUsersByUsernameHandler
	// SetBlockedHandler sets the operation handler for the set blocked operation
	SetBlockedHandler SetBlockedHandler
	// SetEmailHandler sets the operation handler for the set email operation
	SetEmailHandler SetEmailHandler
	// SetNewPasswordHandler sets the operation handler for the set new password operation
	SetNewPasswordHandler SetNewPasswordHandler
	// SetPersDataRegionHandler sets the operation handler for the set pers data region operation
	SetPersDataRegionHandler SetPersDataRegionHandler
	// SetUsernameHandler sets the operation handler for the set username operation
	SetUsernameHandler SetUsernameHandler
	// ValidateNewEmailHandler sets the operation handler for the validate new email operation
	ValidateNewEmailHandler ValidateNewEmailHandler
	// ValidateRegistrationEmailHandler sets the operation handler for the validate registration email operation
	ValidateRegistrationEmailHandler ValidateRegistrationEmailHandler
	// ServeError is called when an error is received, there is a default handler
	// but you can set your own with this
	ServeError func(http.ResponseWriter, *http.Request, error)

	// PreServerShutdown is called before the HTTP(S) server is shutdown
	// This allows for custom functions to get executed before the HTTP(S) server stops accepting traffic
	PreServerShutdown func()

	// ServerShutdown is called when the HTTP(S) server is shut down and done
	// handling all active connections and does not accept connections any more
	ServerShutdown func()

	// Custom command line argument groups with their descriptions
	CommandLineOptionsGroups []swag.CommandLineOptionsGroup

	// User defined logger function.
	Logger func(string, ...interface{})
}

// UseRedoc for documentation at /docs
func (o *AuthenticationAPI) UseRedoc() {
	o.useSwaggerUI = false
}

// UseSwaggerUI for documentation at /docs
func (o *AuthenticationAPI) UseSwaggerUI() {
	o.useSwaggerUI = true
}

// SetDefaultProduces sets the default produces media type
func (o *AuthenticationAPI) SetDefaultProduces(mediaType string) {
	o.defaultProduces = mediaType
}

// SetDefaultConsumes returns the default consumes media type
func (o *AuthenticationAPI) SetDefaultConsumes(mediaType string) {
	o.defaultConsumes = mediaType
}

// SetSpec sets a spec that will be served for the clients.
func (o *AuthenticationAPI) SetSpec(spec *loads.Document) {
	o.spec = spec
}

// DefaultProduces returns the default produces media type
func (o *AuthenticationAPI) DefaultProduces() string {
	return o.defaultProduces
}

// DefaultConsumes returns the default consumes media type
func (o *AuthenticationAPI) DefaultConsumes() string {
	return o.defaultConsumes
}

// Formats returns the registered string formats
func (o *AuthenticationAPI) Formats() strfmt.Registry {
	return o.formats
}

// RegisterFormat registers a custom format validator
func (o *AuthenticationAPI) RegisterFormat(name string, format strfmt.Format, validator strfmt.Validator) {
	o.formats.Add(name, format, validator)
}

// Validate validates the registrations in the AuthenticationAPI
func (o *AuthenticationAPI) Validate() error {
	var unregistered []string

	if o.JSONConsumer == nil {
		unregistered = append(unregistered, "JSONConsumer")
	}

	if o.JSONProducer == nil {
		unregistered = append(unregistered, "JSONProducer")
	}

	if o.CookieKeyAuth == nil {
		unregistered = append(unregistered, "CookieAuth")
	}
	if o.CsrfTokenAuth == nil {
		unregistered = append(unregistered, "XCSRFTokenBoundAuth")
	}

	if o.ChangePasswordHandler == nil {
		unregistered = append(unregistered, "ChangePasswordHandler")
	}
	if o.DeleteUserHandler == nil {
		unregistered = append(unregistered, "DeleteUserHandler")
	}
	if o.GetUserProfileHandler == nil {
		unregistered = append(unregistered, "GetUserProfileHandler")
	}
	if o.GetUserProfileByIDHandler == nil {
		unregistered = append(unregistered, "GetUserProfileByIDHandler")
	}
	if o.IsEmailAvailableHandler == nil {
		unregistered = append(unregistered, "IsEmailAvailableHandler")
	}
	if o.IsUsernameAvailableHandler == nil {
		unregistered = append(unregistered, "IsUsernameAvailableHandler")
	}
	if o.LoginHandler == nil {
		unregistered = append(unregistered, "LoginHandler")
	}
	if o.LogoutHandler == nil {
		unregistered = append(unregistered, "LogoutHandler")
	}
	if o.RegisterHandler == nil {
		unregistered = append(unregistered, "RegisterHandler")
	}
	if o.RegisterLoginOAuthHandler == nil {
		unregistered = append(unregistered, "RegisterLoginOAuthHandler")
	}
	if o.ResetPasswordHandler == nil {
		unregistered = append(unregistered, "ResetPasswordHandler")
	}
	if o.SearchUsersByUsernameHandler == nil {
		unregistered = append(unregistered, "SearchUsersByUsernameHandler")
	}
	if o.SetBlockedHandler == nil {
		unregistered = append(unregistered, "SetBlockedHandler")
	}
	if o.SetEmailHandler == nil {
		unregistered = append(unregistered, "SetEmailHandler")
	}
	if o.SetNewPasswordHandler == nil {
		unregistered = append(unregistered, "SetNewPasswordHandler")
	}
	if o.SetPersDataRegionHandler == nil {
		unregistered = append(unregistered, "SetPersDataRegionHandler")
	}
	if o.SetUsernameHandler == nil {
		unregistered = append(unregistered, "SetUsernameHandler")
	}
	if o.ValidateNewEmailHandler == nil {
		unregistered = append(unregistered, "ValidateNewEmailHandler")
	}
	if o.ValidateRegistrationEmailHandler == nil {
		unregistered = append(unregistered, "ValidateRegistrationEmailHandler")
	}

	if len(unregistered) > 0 {
		return fmt.Errorf("missing registration: %s", strings.Join(unregistered, ", "))
	}

	return nil
}

// ServeErrorFor gets a error handler for a given operation id
func (o *AuthenticationAPI) ServeErrorFor(operationID string) func(http.ResponseWriter, *http.Request, error) {
	return o.ServeError
}

// AuthenticatorsFor gets the authenticators for the specified security schemes
func (o *AuthenticationAPI) AuthenticatorsFor(schemes map[string]spec.SecurityScheme) map[string]runtime.Authenticator {
	result := make(map[string]runtime.Authenticator)
	for name := range schemes {
		switch name {
		case "cookieKey":
			scheme := schemes[name]
			result[name] = o.APIKeyAuthenticator(scheme.Name, scheme.In, o.CookieKeyAuth)

		case "csrfToken":
			scheme := schemes[name]
			result[name] = o.APIKeyAuthenticator(scheme.Name, scheme.In, o.CsrfTokenAuth)

		}
	}
	return result
}

// Authorizer returns the registered authorizer
func (o *AuthenticationAPI) Authorizer() runtime.Authorizer {
	return o.APIAuthorizer
}

// ConsumersFor gets the consumers for the specified media types.
// MIME type parameters are ignored here.
func (o *AuthenticationAPI) ConsumersFor(mediaTypes []string) map[string]runtime.Consumer {
	result := make(map[string]runtime.Consumer, len(mediaTypes))
	for _, mt := range mediaTypes {
		switch mt {
		case "application/json":
			result["application/json"] = o.JSONConsumer
		}

		if c, ok := o.customConsumers[mt]; ok {
			result[mt] = c
		}
	}
	return result
}

// ProducersFor gets the producers for the specified media types.
// MIME type parameters are ignored here.
func (o *AuthenticationAPI) ProducersFor(mediaTypes []string) map[string]runtime.Producer {
	result := make(map[string]runtime.Producer, len(mediaTypes))
	for _, mt := range mediaTypes {
		switch mt {
		case "application/json":
			result["application/json"] = o.JSONProducer
		}

		if p, ok := o.customProducers[mt]; ok {
			result[mt] = p
		}
	}
	return result
}

// HandlerFor gets a http.Handler for the provided operation method and path
func (o *AuthenticationAPI) HandlerFor(method, path string) (http.Handler, bool) {
	if o.handlers == nil {
		return nil, false
	}
	um := strings.ToUpper(method)
	if _, ok := o.handlers[um]; !ok {
		return nil, false
	}
	if path == "/" {
		path = ""
	}
	h, ok := o.handlers[um][path]
	return h, ok
}

// Context returns the middleware context for the authentication API
func (o *AuthenticationAPI) Context() *middleware.Context {
	if o.context == nil {
		o.context = middleware.NewRoutableContext(o.spec, o, nil)
	}

	return o.context
}

func (o *AuthenticationAPI) initHandlerCache() {
	o.Context() // don't care about the result, just that the initialization happened
	if o.handlers == nil {
		o.handlers = make(map[string]map[string]http.Handler)
	}

	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/change-password"] = NewChangePassword(o.context, o.ChangePasswordHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/delete-user"] = NewDeleteUser(o.context, o.DeleteUserHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/get-user-profile"] = NewGetUserProfile(o.context, o.GetUserProfileHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/get-user-profile-by-id"] = NewGetUserProfileByID(o.context, o.GetUserProfileByIDHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/is-email-available"] = NewIsEmailAvailable(o.context, o.IsEmailAvailableHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/is-username-available"] = NewIsUsernameAvailable(o.context, o.IsUsernameAvailableHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/login"] = NewLogin(o.context, o.LoginHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/logout"] = NewLogout(o.context, o.LogoutHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/register"] = NewRegister(o.context, o.RegisterHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/register-login-oauth"] = NewRegisterLoginOAuth(o.context, o.RegisterLoginOAuthHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/reset-password"] = NewResetPassword(o.context, o.ResetPasswordHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/search-users-by-username"] = NewSearchUsersByUsername(o.context, o.SearchUsersByUsernameHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/set-blocked"] = NewSetBlocked(o.context, o.SetBlockedHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/set-email"] = NewSetEmail(o.context, o.SetEmailHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/set-new-password"] = NewSetNewPassword(o.context, o.SetNewPasswordHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/set-persdata-region"] = NewSetPersDataRegion(o.context, o.SetPersDataRegionHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/set-username"] = NewSetUsername(o.context, o.SetUsernameHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/validate-new-email"] = NewValidateNewEmail(o.context, o.ValidateNewEmailHandler)
	if o.handlers["POST"] == nil {
		o.handlers["POST"] = make(map[string]http.Handler)
	}
	o.handlers["POST"]["/validate-registration-email"] = NewValidateRegistrationEmail(o.context, o.ValidateRegistrationEmailHandler)
}

// Serve creates a http handler to serve the API over HTTP
// can be used directly in http.ListenAndServe(":8000", api.Serve(nil))
func (o *AuthenticationAPI) Serve(builder middleware.Builder) http.Handler {
	o.Init()

	if o.Middleware != nil {
		return o.Middleware(builder)
	}
	if o.useSwaggerUI {
		return o.context.APIHandlerSwaggerUI(builder)
	}
	return o.context.APIHandler(builder)
}

// Init allows you to just initialize the handler cache, you can then recompose the middleware as you see fit
func (o *AuthenticationAPI) Init() {
	if len(o.handlers) == 0 {
		o.initHandlerCache()
	}
}

// RegisterConsumer allows you to add (or override) a consumer for a media type.
func (o *AuthenticationAPI) RegisterConsumer(mediaType string, consumer runtime.Consumer) {
	o.customConsumers[mediaType] = consumer
}

// RegisterProducer allows you to add (or override) a producer for a media type.
func (o *AuthenticationAPI) RegisterProducer(mediaType string, producer runtime.Producer) {
	o.customProducers[mediaType] = producer
}

// AddMiddlewareFor adds a http middleware to existing handler
func (o *AuthenticationAPI) AddMiddlewareFor(method, path string, builder middleware.Builder) {
	um := strings.ToUpper(method)
	if path == "/" {
		path = ""
	}
	o.Init()
	if h, ok := o.handlers[um][path]; ok {
		o.handlers[method][path] = builder(h)
	}
}

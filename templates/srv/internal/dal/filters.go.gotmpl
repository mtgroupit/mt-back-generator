// Code generated by mtgroup-generator.
package dal

import (
	"{{.Module}}/internal/app"
	"{{.Module}}/internal/types"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/go-openapi/strfmt"
	"github.com/google/uuid"
	"github.com/pkg/errors"
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

var errNotExistFilterKey = errors.New("Filter key does not exist")

type builderFilter struct {
	filterGroups []*app.FilterGroup
	columnsProps map[string]columnProps
	namedVars    map[string]interface{}
}

type columnProps struct {
	sqlName  string
	typeName string
	isArray  bool
}

func newBuilderFilter(filterGroups []*app.FilterGroup, columnsProps map[string]columnProps) *builderFilter {
	return &builderFilter{
		filterGroups: filterGroups,
		columnsProps: columnsProps,
		namedVars:    make(map[string]interface{}),
	}
}

func (bf *builderFilter) preparedSQLFilters() (sql string, vars map[string]interface{}, warnings []string) {
	for _, filterGroup := range bf.modelFilterGroups() {
		var filterStrs []string
		for _, filter := range filterGroup.Filters {
			filterStr, err := bf.newFilterStr(filterGroup.Key, filter)
			if err == nil {
				filterStrs = append(filterStrs, filterStr)
			} else {
				warnings = append(warnings, err.Error())
			}
		}
		if len(filterStrs) > 0 {
			sql += fmt.Sprintf(" AND (%s)\n", strings.Join(filterStrs, " "+logicFilterStr(filterGroup.LogicFilter)+" "))
		}
	}
	vars = bf.namedVars
	return
}

func (bf *builderFilter) modelFilterGroups() []*app.FilterGroup {
	var result []*app.FilterGroup
	for _, group := range bf.filterGroups {
		if !strings.Contains(group.Key, ".") && !bf.columnsProps[group.Key].isArray {
			result = append(result, group)
		}
	}
	return result
}

func (bf *builderFilter) nestedFilterGroups() []*app.FilterGroup {
	var result []*app.FilterGroup
	for _, group := range bf.filterGroups {
		if strings.Contains(group.Key, ".") || bf.columnsProps[group.Key].isArray {
			result = append(result, group)
		}
	}
	return result
}

func (bf *builderFilter) newFilterStr(column string, filter *app.Filter) (string, error) {
	sqlName, columnType, err := bf.parseColumn(column)
	if err != nil {
		return "", err
	}
	if err := validateOperator(filter.Operator, columnType); err != nil {
		return "", err
	}
	if err := vaidateIgnoreCase(filter.IgnoreCase, columnType); err != nil {
		return "", err
	}
	if err := validateValue(filter.Value, columnType); err != nil {
		return "", err
	}
	namedVarKey := bf.newNamedVar(sqlName, filter.Value)
	var filterStr string
	if columnType == "string" && filter.IgnoreCase {
		switch filter.Operator {
		case "==":
			filterStr = fmt.Sprintf(equalSQLFilterStrIgnoreCase, sqlName, namedVarKey)
		case "!=":
			filterStr = fmt.Sprintf(notEqualSQLFilterStrIgnoreCase, sqlName, namedVarKey)
		case "<":
			filterStr = fmt.Sprintf(lessSQLFilterStrIgnoreCase, sqlName, namedVarKey)
		case ">":
			filterStr = fmt.Sprintf(greaterSQLFilterStrIgnoreCase, sqlName, namedVarKey)
		case "<=":
			filterStr = fmt.Sprintf(lessOrEqualSQLFilterStrIgnoreCase, sqlName, namedVarKey)
		case ">=":
			filterStr = fmt.Sprintf(greaterOrEqualSQLFilterStrIgnoreCase, sqlName, namedVarKey)
		case "in":
			filterStr = fmt.Sprintf(containSQLFilterStrIgnoreCase, sqlName, namedVarKey)
		case "!in":
			filterStr = fmt.Sprintf(notContainSQLFilterStrIgnoreCase, sqlName, namedVarKey)
		}
	} else if columnType == "date" {
		switch filter.Operator {
		case "==":
			filterStr = fmt.Sprintf(equalSQLFilterDate, sqlName, namedVarKey)
		case "!=":
			filterStr = fmt.Sprintf(notEqualSQLFilterDate, sqlName, namedVarKey)
		case "<":
			filterStr = fmt.Sprintf(lessSQLFilterDate, sqlName, namedVarKey)
		case ">":
			filterStr = fmt.Sprintf(greaterSQLFilterDate, sqlName, namedVarKey)
		case "<=":
			filterStr = fmt.Sprintf(lessOrEqualSQLFilterDate, sqlName, namedVarKey)
		case ">=":
			filterStr = fmt.Sprintf(greaterOrEqualSQLFilterDate, sqlName, namedVarKey)
		}
	} else {
		switch filter.Operator {
		case "==":
			filterStr = fmt.Sprintf(equalSQLFilter, sqlName, namedVarKey)
		case "!=":
			filterStr = fmt.Sprintf(notEqualSQLFilter, sqlName, namedVarKey)
		case "<":
			filterStr = fmt.Sprintf(lessSQLFilter, sqlName, namedVarKey)
		case ">":
			filterStr = fmt.Sprintf(greaterSQLFilter, sqlName, namedVarKey)
		case "<=":
			filterStr = fmt.Sprintf(lessOrEqualSQLFilter, sqlName, namedVarKey)
		case ">=":
			filterStr = fmt.Sprintf(greaterOrEqualSQLFilter, sqlName, namedVarKey)
		case "in":
			filterStr = fmt.Sprintf(containSQLFilter, sqlName, namedVarKey)
		case "!in":
			filterStr = fmt.Sprintf(notContainSQLFilter, sqlName, namedVarKey)
		}
	}
	if filter.Operator == "in" || filter.Operator == "!in" {
		bf.namedVars[namedVarKey] = "%%" + filter.Value + "%%"
	} else {
		bf.namedVars[namedVarKey] = filter.Value
	}
	return filterStr, nil
}

func (bf *builderFilter) parseColumn(column string) (string, string, error) {
	columnProps, ok := bf.columnsProps[column]
	if ok {
		return columnProps.sqlName, columnProps.typeName, nil
	}
	return "", "", errors.Errorf(`Model has not "%s" column for filtering or filtering is not available for this column`, column)
}

func (bf *builderFilter) newNamedVar(key, value string) string {
	for i := 0; ; i++ {
		if _, ok := bf.namedVars[key+strconv.Itoa(i)]; !ok {
			bf.namedVars[key+strconv.Itoa(i)] = value
			return key + strconv.Itoa(i)
		}
	}
}

func (bf *builderFilter) validateAvailableFilters(availableFilterKeys map[string]bool) (warnings []string) {
	for i, filterGroup := range bf.filterGroups {
		if _, ok := availableFilterKeys[filterGroup.Key]; !ok {
			warnings = append(warnings, fmt.Sprintf("Key '%s' is not available", filterGroup.Key))
			bf.filterGroups = append(bf.filterGroups[:i], bf.filterGroups[i+1:]...)
			i--
		}
	}
	return
}

func validateValue(value, columnType string) (err error) {
	switch columnType {
	case "uuid":
		_, err = uuid.Parse(value)
	case "int32", "int64":
		_, err = strconv.Atoi(value)
	case "bool":
		_, err = strconv.ParseBool(value)
	case "float":
		_, err = strconv.ParseFloat(value, 64)
	case "decimal":
		_, err = types.NewDecimalFromString(value)
	case "date":
		_, err = time.Parse(strfmt.RFC3339FullDate, value)
	case "date-time":
		_, err = time.Parse(time.RFC3339, value)
	}
	err = errors.Wrapf(err, "filter value '%s' not correct for '%s' type", value, columnType)
	return
}

func validateOperator(operator, columnType string) error {
	switch operator {
	case "==", "!=":
		return nil
	case "<", ">", "<=", ">=":
		if columnType == "bool" || columnType == "uuid" {
			return errors.Errorf("Operator '%s' not available for type '%s'.", operator, columnType)
		}
		return nil
	case "in", "!in":
		if columnType != "string" {
			return errors.Errorf("Operator '%s' not available for type '%s'.", operator, columnType)
		}
		return nil
	default:
		return errors.Errorf("Operator '%s' not available. Filter supports only these operators: '==', '!=', '<', '>', '<=', '>=', 'in', '!in'", operator)
	}
}

func vaidateIgnoreCase(ignoreCase bool, columnType string) error {
	if ignoreCase && columnType != "string" {
		return errors.New("IgnoreCase 'true' availabale only for 'string' type")
	}
	return nil
}

func logicFilterStr(LogicFilter bool) string {
	if LogicFilter {
		return "AND"
	} else {
		return "OR"
	}
}

var (
	equalSQLFilter                       = "(%s = :%s)"
	notEqualSQLFilter                    = "(%s <> :%s)"
	lessSQLFilter                        = "(%s < :%s)"
	greaterSQLFilter                     = "(%s > :%s)"
	lessOrEqualSQLFilter                 = "(%s <= :%s)"
	greaterOrEqualSQLFilter              = "(%s >= :%s)"
	containSQLFilter                     = "(%s LIKE :%s)"
	notContainSQLFilter                  = "(%s NOT LIKE :%s)"
	equalSQLFilterStrIgnoreCase          = "(LOWER(%s) = LOWER(:%s))"
	notEqualSQLFilterStrIgnoreCase       = "(LOWER(%s) <> LOWER(:%s))"
	lessSQLFilterStrIgnoreCase           = "(LOWER(%s) < LOWER(:%s))"
	greaterSQLFilterStrIgnoreCase        = "(LOWER(%s) > LOWER(:%s))"
	lessOrEqualSQLFilterStrIgnoreCase    = "(LOWER(%s) <= LOWER(:%s))"
	greaterOrEqualSQLFilterStrIgnoreCase = "(LOWER(%s) >= LOWER(:%s))"
	containSQLFilterStrIgnoreCase        = "(LOWER(%s) LIKE LOWER(:%s))"
	notContainSQLFilterStrIgnoreCase     = "(LOWER(%s) NOT LIKE LOWER(:%s))"
	equalSQLFilterDate                   = "(DATE(%s) = DATE(:%s))"
	notEqualSQLFilterDate                = "(DATE(%s) <> DATE(:%s))"
	lessSQLFilterDate                    = "(DATE(%s) < DATE(:%s))"
	greaterSQLFilterDate                 = "(DATE(%s) > DATE(:%s))"
	lessOrEqualSQLFilterDate             = "(DATE(%s) <= DATE(:%s))"
	greaterOrEqualSQLFilterDate          = "(DATE(%s) >= DATE(:%s))"
)

func compareString(operator string, ignoreCase bool, realValue, filterValue string) bool {
	if ignoreCase {
		realValue = strings.ToLower(realValue)
		filterValue = strings.ToLower(filterValue)
	}
	switch operator {
	case "==":
		return realValue == filterValue
	case "!=":
		return realValue != filterValue
	case "<":
		return realValue < filterValue
	case ">":
		return realValue > filterValue
	case "<=":
		return realValue <= filterValue
	case ">=":
		return realValue >= filterValue
	case "in":
		return strings.Contains(realValue, filterValue)
	case "!in":
		return !strings.Contains(realValue, filterValue)
	default:
		return false
	}
}

func compareTime(operator string, realValue time.Time, filterValue string) bool {
	filterValueTime, err := time.Parse(time.RFC3339, filterValue)
	if err != nil {
		return false
	}
	realValue, filterValueTime = realValue.Round(time.Millisecond), filterValueTime.Round(time.Millisecond)
	switch operator {
	case "==":
		return realValue.Equal(filterValueTime)
	case "!=":
		return !realValue.Equal(filterValueTime)
	case "<":
		return realValue.Before(filterValueTime)
	case ">":
		return realValue.After(filterValueTime)
	case "<=":
		return realValue.Before(filterValueTime) || realValue.Equal(filterValueTime)
	case ">=":
		return realValue.After(filterValueTime) || realValue.Equal(filterValueTime)
	default:
		return false
	}
}

func compareDate(operator string, realValue time.Time, filterValue string) bool {
	filterValueDate, err := time.Parse(strfmt.RFC3339FullDate, filterValue)
	if err != nil {
		return false
	}
	realValue, filterValueDate = realValue.Round(24*time.Hour), filterValueDate.Round(24*time.Hour)
	switch operator {
	case "==":
		return realValue.Equal(filterValueDate)
	case "!=":
		return !realValue.Equal(filterValueDate)
	case "<":
		return realValue.Before(filterValueDate)
	case ">":
		return realValue.After(filterValueDate)
	case "<=":
		return realValue.Before(filterValueDate) || realValue.Equal(filterValueDate)
	case ">=":
		return realValue.After(filterValueDate) || realValue.Equal(filterValueDate)
	default:
		return false
	}
}

func compareUUID(operator string, realValue uuid.UUID, filterValue string) bool {
	switch operator {
	case "==":
		return realValue.String() == filterValue
	case "!=":
		return realValue.String() != filterValue
	default:
		return false
	}
}

func compareInt64(operator string, realValue int64, filterValue string) bool {
	filterValueInt, err := strconv.Atoi(filterValue)
	if err != nil {
		return false
	}
	filterValueInt64 := int64(filterValueInt)
	switch operator {
	case "==":
		return realValue == filterValueInt64
	case "!=":
		return realValue != filterValueInt64
	case "<":
		return realValue < filterValueInt64
	case ">":
		return realValue > filterValueInt64
	case "<=":
		return realValue <= filterValueInt64
	case ">=":
		return realValue >= filterValueInt64
	default:
		return false
	}
}

func compareFloat64(operator string, realValue float64, filterValue string) bool {
	filterValueFloat64, err := strconv.ParseFloat(filterValue, 64)
	if err != nil {
		return false
	}
	switch operator {
	case "==":
		return realValue == filterValueFloat64
	case "!=":
		return realValue != filterValueFloat64
	case "<":
		return realValue < filterValueFloat64
	case ">":
		return realValue > filterValueFloat64
	case "<=":
		return realValue <= filterValueFloat64
	case ">=":
		return realValue >= filterValueFloat64
	default:
		return false
	}
}

func compareDecimal(operator string, realValue types.Decimal, filterValue string) bool {
	filterValueDecimal, err := types.NewDecimalFromString(filterValue)
	if err != nil {
		return false
	}
	switch operator {
	case "==":
		return realValue.Equal(filterValueDecimal)
	case "!=":
		return !realValue.Equal(filterValueDecimal)
	case "<":
		return realValue.LessThan(filterValueDecimal)
	case ">":
		return !realValue.LessThanOrEqual(filterValueDecimal)
	case "<=":
		return realValue.LessThanOrEqual(filterValueDecimal)
	case ">=":
		return !realValue.LessThan(filterValueDecimal)
	default:
		return false
	}
}

func compareBool(operator string, realValue bool, filterValue string) bool {
	filterValueBool, err := strconv.ParseBool(filterValue)
	if err != nil {
		return false
	}
	switch operator {
	case "==":
		return realValue == filterValueBool
	case "!=":
		return realValue != filterValueBool
	default:
		return false
	}
}

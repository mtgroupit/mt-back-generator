// Code generated by mtgroup-generator.  {{$modelName := .CurModel}} {{$model := (index $.Models $modelName)}} {{$models := .Models}} {{$haveNestedSorts := false}}{{range $_, $opts := $model.Columns}}{{if $opts.NestedSorts}}{{$haveNestedSorts = true}}{{end}}{{end}}
package dal

import (
	"database/sql"	{{if $model.HaveLazyLoading}}
	"strings"{{end}}{{if $haveNestedSorts}}
	"sort"{{end}}{{if and $model.HaveLazyLoading $model.HaveListMethod}}
	"fmt"{{end}}

	"{{.Module}}/internal/app"

	{{if $model.IDIsUUID}}"github.com/google/uuid"{{else}}{{$inputed := false}}{{range $name, $options := $model.Columns}}{{$model2 := (index $.Models $options.GoType)}}{{if and $model2.IDIsUUID (not $inputed) (not $options.IsArray)}}"github.com/google/uuid"{{$inputed = true}}{{end}}{{end}}{{end}}
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

type {{$modelName}} struct { {{range $i, $psqlParams := $model.Psql}}{{if $psqlParams.IsStruct}}
	{{if not $psqlParams.IsArray}}{{$psqlParams.Name}}ID {{if eq  $psqlParams.TypeSQL "uuid"}}uuid.UUID{{else}}int64{{end}} `db:"{{$psqlParams.SQLName}}"`{{end}}
	{{$psqlParams.Name}} {{if $psqlParams.IsArray}}[]{{end}}{{$psqlParams.Type}}{{else}}
	{{$psqlParams.Name}} {{if eq  $psqlParams.TypeSQL "uuid"}}uuid.UUID{{else}}sql.Null{{Title $psqlParams.Type}}{{end}} `db:"{{$psqlParams.SQLName}}"` {{end}}{{end}}
}

{{range $i, $method := $model.Methods}}{{if not (IsCustomMethod $method)}}
{{if eq $method "Get"}}func (a *App) {{$method}}{{$modelName}}(id {{if $model.IDIsUUID}}string{{else}}int64{{end}}) (*app.{{$modelName}}, error) { 
	return a.get{{$modelName}}(id)
}{{end}}
{{if eq $method "Add"}}func (a *App) {{$method}}{{$modelName}}({{if $model.IDFromProfile}}profileID string, {{end}}m *app.{{$modelName}}) (*app.{{$modelName}}, error) {
	id, err := a.add{{$modelName}}({{if $model.IDFromProfile}}profileID, {{end}}m)
	if err != nil {
		return nil, err
	}
	return a.get{{$modelName}}(id)
}{{end}}
{{if eq $method "Delete"}}func (a *App) {{$method}}{{$modelName}}(id {{if $model.IDIsUUID}}string{{else}}int64{{end}}) error { {{range $modelName2, $model2 := $.Models}}{{range $column, $options := $model.Columns}}{{if eq $modelName2 $options.GoType}}{{if $options.IsArray}}
	if _, err := a.db.Exec(`DELETE FROM {{NameSQL $modelName}}_{{NameSQL $column}} WHERE {{NameSQL $modelName}}_id=$1`, id); err != nil {
		return err
	}{{end}}{{end}}{{end}}{{end}} {{range $_, $bind := $model.Binds}}{{if $bind.IsArray}}
	if _, err := a.db.Exec(`DELETE FROM {{NameSQL $bind.ModelName}}_{{NameSQL $bind.FieldName}} WHERE {{NameSQL $bind.FieldName}}_id=$1`, id); err != nil {
		return err
	}{{else}}
	if _, err := a.db.Exec(`UPDATE {{NameSQL $bind.ModelName}}s SET {{$bind.FieldName}}_id=NULL WHERE {{NameSQL $bind.FieldName}}_id=$1`, id); err != nil {
		return err
	}{{end}}{{end}}
	if _, err := a.db.Exec(`DELETE FROM {{NameSQL $modelName}}s WHERE id=$1`, id); err != nil {
		return err
	}
	return nil
}{{end}}
{{if or (eq $method "Edit") (IsCustomEdit $method)}}func (a *App) {{$method}}{{$modelName}}(id {{if $model.IDIsUUID}}string{{else}}int64{{end}}, m *app.{{$modelName}}) {{if $model.ReturnWhenEdit}}(*app.{{$modelName}}, error){{else}}error{{end}}  { {{range $column, $options := $model.Columns}}{{if and (and $options.IsStruct (not $options.IsArray)) (or (not (IsCustomEdit $method)) (and (ContainsStr (index $model.MethodsProps $i).EditableFields $column) (IsCustomEdit $method)))}}
	var {{$column}}ID interface{}
	if m.{{$options.TitleName}} != nil {
		{{$column}}ID = m.{{$options.TitleName}}.ID
	}{{end}}{{end}}
	if _, err := a.db.Exec(`UPDATE {{NameSQL $modelName}}s SET {{if  (IsCustomEdit $method)}}{{(index $model.MethodsProps $i).CustomSQLEditStr}}{{else}}{{$model.SQLEditStr}}{{end}} WHERE id=$1`, id, {{if  (IsCustomEdit $method)}}{{(index $model.MethodsProps $i).CustomSQLExecParams}}{{else}}{{$model.SQLExecParams}}{{end}}); err != nil {
		return {{if $model.ReturnWhenEdit}}nil, {{end}}err
	}
	{{if $model.ReturnWhenEdit}}
	var edited {{$modelName}}
	if err := a.db.Get(&edited, `SELECT {{$model.SQLSelectStr}} FROM {{NameSQL $modelName}}s WHERE id=$1`, id); err != nil {
		return nil, err
	}{{if $model.HaveLazyLoading}}
	if err := edited.LazyLoading(a); err != nil {
		return nil, err
	}{{end}}{{end}}
	return {{if $model.ReturnWhenEdit}}app{{$modelName}}(edited), {{end}}nil
}{{end}}

{{if or (eq $method "List") (IsCustomList $method)}}func (a *App) {{$method}}{{$modelName}}(offset, limit int64, filters []*app.Filter, sortBy,orderBy string) ([]*app.{{$modelName}}, {{if $model.DetailedPagination}} int,{{end}}[]string, error) { 
	ms := []{{$modelName}}{}
	warnings := []string{}

	var orderQuery string {{if $haveNestedSorts}}
	var nestedSort bool {{end}}
	switch sortBy { {{range $column, $options := $model.Columns}}{{if and $options.SortOn (not $options.IsStruct)}}
	case "{{$column}}":
		orderQuery = "ORDER BY " + sortBy{{end}}{{end}}
	default:{{range $column, $options := $model.Columns}}{{if $options.SortDefault}}{{if $haveNestedSorts}}
		if sortBy == "" { {{end}}
			orderQuery = "ORDER BY {{$column}}"{{end}}{{end}}{{if $haveNestedSorts}}
		} else {
			nestedSort = true
		}{{end}}
	}
	if orderQuery != "" {
		switch orderBy {
		case "ASC", "":
			orderQuery += " ASC"
		case "DESC":
			orderQuery += " DESC"
		}
	}

	mapQuery := map[string]interface{}{ {{if IsCustomList $method}}{{range $_, $column := (index $model.MethodsProps $i).FilteredFields}}
		"{{$column}}": nil,
		"not_{{$column}}": nil,{{end}}{{else}}{{range $column, $options := $model.Columns}}{{if not $options.IsArray}}
		"{{$column}}": nil,
		"not_{{$column}}": nil,{{end}}{{end}}{{end}}
		"offset": offset,
		"limit": limit,
	}

	customFilters := []*app.Filter{}
	{{if or (index $model.MethodsProps $i).FilteredFields (not (IsCustomList $method))}}
	for _, filter := range filters {
		switch filter.Key { {{if IsCustomList $method}}{{range $_, $column := (index $model.MethodsProps $i).FilteredFields}}
		case "{{$column}}":
			if filter.Include {
				mapQuery["{{$column}}"] = filter.Value
			} else {
				mapQuery["not_{{$column}}"] = filter.Value
			}{{end}}{{else}}{{range $column, $options := $model.Columns}}{{if not $options.IsArray}}
		case "{{$column}}":
			if filter.Include {
				mapQuery["{{$column}}"] = filter.Value
			} else {
				mapQuery["not_{{$column}}"] = filter.Value
			}{{end}}{{end}}{{end}}
		default:
			customFilters = append(customFilters, filter)
		}
	}{{end}}
	{{if $model.DetailedPagination}}
	rows, err := a.db.NamedQuery(`SELECT COUNT(*) FROM {{NameSQL $modelName}}s {{if or (index $model.MethodsProps $i).FilteredFields (not (IsCustomList $method))}}WHERE {{end}}{{if  (IsCustomList $method)}}{{(index $model.MethodsProps $i).CustomListSQLWhereProps}}{{else}}{{$model.SQLWhereParams}}{{end}}`, mapQuery)
	if err != nil {
		return nil, -1, nil, err
	}
	var count int
	for rows.Next() {
		err = rows.Scan(&count)
	}
	{{end}}
	rows, err {{if not $model.DetailedPagination}}:{{end}}= a.db.NamedQuery(`SELECT {{if  (IsCustomList $method)}}{{(index $model.MethodsProps $i).CustomListSQLSelect}}{{else}}{{$model.SQLSelectStr}}{{end}} FROM {{NameSQL $modelName}}s {{if or (index $model.MethodsProps $i).FilteredFields (not (IsCustomList $method))}}WHERE {{end}}{{if  (IsCustomList $method)}}{{(index $model.MethodsProps $i).CustomListSQLWhereProps}}{{else}}{{$model.SQLWhereParams}}{{end}} ` + orderQuery + ` OFFSET :offset LIMIT :limit`, mapQuery)
	if err != nil {
		return nil,{{if $model.DetailedPagination}} -1,{{end}} nil, err
	}
	for rows.Next() {
		var m {{$modelName}}
		err = rows.StructScan(&m)
		ms = append(ms, m)
	}
	
	{{if $model.HaveLazyLoading}}
	result := []{{$modelName}}{}
	{{if (IsCustomList $method)}}{{if ((index $model.MethodsProps $i).NeedLazyLoading)}}
	for i := range ms {
		if err := ms[i].LazyLoading{{$method}}(a); err != nil {
			return nil,{{if $model.DetailedPagination}} -1,{{end}} nil, err
		}
		ok := true
		for j := 0; j < len(customFilters); j++ {
			var validFilter bool
			ok, validFilter = ms[i].{{if $model.HaveLazyLoading}}Nested{{end}}Filter(customFilters[j])
			if !validFilter {
				warnings = append(warnings, fmt.Sprintf("filter key '%s' is not valid", customFilters[j].Key))
				customFilters = append(customFilters[:j], customFilters[j+1:]...)
				j--
			}
		}
		if ok {
			result = append(result, ms[i])
		}
	}{{end}}{{else}}
	for i := range ms {
		if err := ms[i].LazyLoading(a); err != nil {
			return nil,{{if $model.DetailedPagination}} -1,{{end}} nil, err
		}
		ok := true
		for j := 0; j < len(customFilters); j++ {
			var validFilter bool
			ok, validFilter = ms[i].{{if $model.HaveLazyLoading}}Nested{{end}}Filter(customFilters[j])
			if !validFilter {
				warnings = append(warnings, fmt.Sprintf("filter key '%s' is not valid", customFilters[j].Key))
				customFilters = append(customFilters[:j], customFilters[j+1:]...)
				j--
			}
			if !ok {
				break
			}
		}
		if ok {
			result = append(result, ms[i])
		}
	}{{end}}{{end}}
	{{if $haveNestedSorts}}
	if nestedSort {
		var orderByASC bool
		switch orderBy {
		case "ASC", "":
			orderByASC = true
		case "DESC":
			orderByASC = false
		}
		switch sortBy { {{range $column, $options := $model.Columns}}{{range $j, $sort := $options.SortBy}}
		case "{{$column}}.{{$sort}}":
			if orderByASC {
				sort.Slice({{if $model.HaveLazyLoading}}result{{else}}ms{{end}}, func(i, j int) bool { return {{if $model.HaveLazyLoading}}result{{else}}ms{{end}}[i]{{index $options.NestedSorts $j}} < {{if $model.HaveLazyLoading}}result{{else}}ms{{end}}[j]{{index $options.NestedSorts $j}} })
			} else {
				sort.Slice({{if $model.HaveLazyLoading}}result{{else}}ms{{end}}, func(i, j int) bool { return {{if $model.HaveLazyLoading}}result{{else}}ms{{end}}[i]{{index $options.NestedSorts $j}} >= {{if $model.HaveLazyLoading}}result{{else}}ms{{end}}[j]{{index $options.NestedSorts $j}} })
			}{{end}}{{end}}
		default:
			warnings = append(warnings, fmt.Sprintf("sorting by '%s' is not avaliable or '%s' is not a valid sort key", sortBy))
		}
	}{{end}}

	return app{{$modelName}}s({{if $model.HaveLazyLoading}}result{{else}}ms{{end}}),{{if $model.DetailedPagination}} count,{{end}} warnings, nil
}{{end}}
{{if and (IsCustomList $method) ((index $model.MethodsProps $i).NeedLazyLoading)}}{{range $j, $nestedObj := (index $model.MethodsProps $i).NestedObjs}}
{{if $nestedObj.IsFirstForLazyLoading}}func (m *{{if $nestedObj.Path}}{{$nestedObj.ParentStruct}}{{else}}{{$modelName}}{{end}}) LazyLoading{{$method}}{{$nestedObj.Path}}(a *App) (err error) { {{end}} {{$model2 := (index $.Models $nestedObj.Name)}}{{$options := (index $model2.Columns (LowerTitle $nestedObj.Name))}}{{if  $nestedObj.IsArray}}
	slice{{$options.TitleName}} := []{{if $nestedObj.Path}}{{$nestedObj.ParentStruct}}{{else}}{{$modelName}}{{end}}{{$nestedObj.Type}}{}
	if err = a.db.Select(&slice{{$options.TitleName}}, `SELECT * FROM {{if $nestedObj.Path}}{{NameSQL $nestedObj.ParentStruct}}{{else}}{{NameSQL $modelName}}{{end}}_{{NameSQL $nestedObj.Name}} WHERE {{if $nestedObj.Path}}{{NameSQL $nestedObj.ParentStruct}}{{else}}{{NameSQL $modelName}}{{end}}_id=$1`, m.ID); err != nil {
		return
	}
	for _, cd := range slice{{$options.TitleName}} {
		var elem {{$nestedObj.Type}}
		if err = a.db.Get(&elem, `SELECT {{$nestedObj.SQLSelect}} FROM {{NameSQL $nestedObj.Type}}s WHERE id=$1`, cd. {{$nestedObj.Type}}ID); err != nil {
			return
		}
		{{if $nestedObj.NeedLazyLoading}}
		if err == nil {
			if err = elem.LazyLoading{{$method}}{{$nestedObj.Path}}{{$nestedObj.Name}}(a); err != nil {
				return
			}
		}{{end}}
		m.{{$nestedObj.Name}} = append(m.{{$nestedObj.Name}}, elem)
	}{{else}}
	if err = a.db.Get(&m.{{$nestedObj.Name}}, `SELECT {{$nestedObj.SQLSelect}} FROM {{NameSQL $nestedObj.Type}}s WHERE id=$1`, m.{{$nestedObj.Name}}ID); err != nil && err.Error() != "sql: no rows in result set" {
		return
	}{{if $nestedObj.NeedLazyLoading}}
	if err == nil {
		if err = m.{{$nestedObj.Name}}.LazyLoading{{$method}}{{$nestedObj.Name}}(a); err != nil {
			return
		}
	}{{end}}{{end}}
	{{if $nestedObj.IsLastForLazyLoading}}
	return nil
}{{end}}
{{end}}{{end}}
{{end}}{{end}}

{{if $model.HaveLazyLoading}}
func (m *{{$modelName}}) LazyLoading(a *App) (err error) { {{range $modelName2, $model2 := $.Models}}{{range $column, $options := $model.Columns}}{{if eq $modelName2 $options.GoType}}{{if  $options.IsArray}}
	slice{{$options.TitleName}} := []{{$modelName}}{{$options.GoType}}{}
	if err = a.db.Select(&slice{{$options.TitleName}}, `SELECT * FROM {{NameSQL $modelName}}_{{NameSQL $options.TitleName}} WHERE {{NameSQL $modelName}}_id=$1`, m.ID); err != nil {
		return
	}
	for _, cd := range slice{{$options.TitleName}} {
		var {{$column}} {{$options.GoType}}
		if err = a.db.Get(&{{$column}}, `SELECT {{$model2.SQLSelectStr}} FROM {{NameSQL $options.GoType}}s WHERE id=$1`, cd.{{$options.GoType}}ID); err != nil {
			return
		}{{if $model2.HaveLazyLoading}}
		if err == nil {
			if err = {{$column}}.LazyLoading(a); err != nil {
				return
			}
		}{{end}}
		m.{{$options.TitleName}} = append(m.{{$options.TitleName}}, {{$column}})
	}{{else}}
	if err = a.db.Get(&m.{{$options.TitleName}}, `SELECT {{$model2.SQLSelectStr}} FROM {{NameSQL $modelName2}}s WHERE id=$1`, m.{{$options.TitleName}}ID); err != nil && err.Error() != "sql: no rows in result set" {
		return
	}{{if $model2.HaveLazyLoading}}
	if err == nil {
		if err = m.{{$options.TitleName}}.LazyLoading(a); err != nil {
			return
		}
	}{{end}}{{end}}{{end}}{{end}}{{end}}
	return nil
}
{{end}}
{{range $column, $options := $model.Columns}} {{if $options.IsArray}}
func (a *App) Add{{Title $column}}{{$modelName}}(id {{if $model.IDIsUUID}}string{{else}}int64{{end}}, itemsID []{{if (index $.Models $options.GoType).IDIsUUID}}string{{else}}int64{{end}}, items []*app.{{$options.GoType}}) error {
	for _, item := range items {
		id, err := a.add{{$options.GoType}}(item)
		if err != nil {
			return err
		}
		itemsID = append(itemsID, id)
	}
	for _, itemID := range itemsID {
		if _, err := a.db.Exec(`INSERT INTO {{NameSQL $modelName}}_{{NameSQL $column}}({{NameSQL $modelName}}_id, {{NameSQL $column}}_id) VALUES ($1, $2)`, id, itemID); err != nil {
			return err
		}
	}
	return nil
}

func (a *App) Delete{{Title $column}}{{$modelName}}(id {{if $model.IDIsUUID}}string{{else}}int64{{end}}, items []{{if (index $.Models $options.GoType).IDIsUUID}}string{{else}}int64{{end}}) error {
	for _, item := range items {
		if _, err := a.db.Exec(`DELETE FROM {{NameSQL $modelName}}_{{NameSQL $column}} WHERE {{NameSQL $modelName}}_id=$1 AND {{NameSQL $column}}_id=$2`, id, item); err != nil {
			return err
		}
	}
	return nil
}
{{end}}{{end}}
func (a *App) {{$modelName}}AccessManager(am *app.AccessManager) error {
	if _, err := a.db.Exec(`INSERT INTO {{NameSQL $modelName}}s_access VALUES ($1, $2, $3, $4, $5, $6, $7)`, am.User, am.Group, am.Read, am.Write, am.Delete, am.Add, am.AccessManager); err != nil {
		return err
	}
	return nil
}

func (a *App) get{{$modelName}}(id {{if $model.IDIsUUID}}string{{else}}int64{{end}}) (*app.{{$modelName}}, error) { 
	var m {{$modelName}}
	if err := a.db.Get(&m, `SELECT {{$model.SQLSelectStr}} FROM {{NameSQL $modelName}}s WHERE id=$1`, id); err != nil {
		return nil, err
	}{{if $model.HaveLazyLoading}}
	if err := m.LazyLoading(a); err != nil {
		return nil, err
	}{{end}}
	return app{{$modelName}}(m), nil
}

func (a *App) add{{$modelName}}({{if $model.IDFromProfile}}profileID string, {{end}}m *app.{{$modelName}}) ({{if $model.IDIsUUID}}string{{else}}int64{{end}}, error) {
	{{if $model.IDIsUUID}}{{$modelName}}ID := {{if $model.IDFromProfile}}profileID{{else}}uuid.New(){{end}}{{else}}var {{$modelName}}ID int64{{end}}	{{range $column, $options := $model.Columns}}{{if and $options.IsStruct (not $options.IsArray)}}
	var {{$column}}ID interface{}
	if m.{{$options.TitleName}} != nil {
		{{$column}}ID = m.{{$options.TitleName}}.ID
	}{{end}}{{end}}
	if err := a.db.Get(&{{$modelName}}ID, `INSERT INTO {{NameSQL $modelName}}s{{$model.SQLAddStr}} RETURNING id`, {{$model.SQLExecParams}}{{if $model.IDIsUUID}}, {{$modelName}}ID{{end}}); err != nil {
		return {{if $model.IDIsUUID}}""{{else}}0{{end}}, err
	}{{range $modelName2, $model2 := $.Models}}{{range $column, $options := $model.Columns}}{{if eq $modelName2 $options.GoType}}{{if $options.IsArray}}
	for _, m := range m.{{$options.TitleName}} {
		if _, err := a.db.Exec(`INSERT INTO {{NameSQL $modelName}}_{{NameSQL $column}}({{NameSQL $modelName}}_id, {{NameSQL $column}}_id) VALUES ($1, $2)`, {{$modelName}}ID, m.ID); err != nil {
			return {{if $model.IDIsUUID}}""{{else}}0{{end}}, err
		}
	}{{end}}{{end}}{{end}}{{end}}
	return {{$modelName}}ID{{if $model.IDIsUUID}}{{if not $model.IDFromProfile}}.String(){{end}}{{end}}, nil
}
{{range $functionName, $function := $.Functions}}
func (a *App) {{$functionName}}{{$modelName}}({{$function.InStrFull}}) ({{$function.OutStrType}}, error){
	{{range $name, $type := $function.Out}}var {{$name}} {{$type}}
	{{end}}
	/* Example:
	if err := a.db.Get(&key, `SELECT key FROM components WHERE title=$1`, serviceName); err != nil {
		return "", err
	}*/

	return {{$function.OutStr}}, nil
}{{end}}
{{if $model.HaveLazyLoading}}
func (m *{{$modelName}}) NestedFilter(filter *app.Filter) (ok, filterIsValid bool) {
	if strings.Contains(filter.Key, ".") {
		splitedFilter := strings.SplitN(filter.Key, ".", 2)
		filter.Key = splitedFilter[1]
		switch splitedFilter[0] { {{range $column, $options := $model.Columns}}{{if and $options.IsStruct (not $options.IsArray)}}
		case "{{$column}}":
			ok, filterIsValid = m.{{$options.TitleName}}.{{if (index $models $options.GoType).HaveLazyLoading}}Nested{{end}}Filter(filter){{end}}{{end}}
		default:
			ok, filterIsValid = true, false
		}
	} else {
		ok, filterIsValid = m.Filter(filter)
	}
	return
}{{end}}

func (m *{{$modelName}}) Filter(filter *app.Filter) (ok, filterIsValid bool) {
	switch filter.Key { {{range $column, $options := $model.Columns}}{{if not $options.IsStruct}}
	case "{{$column}}":
		value := toString(m.{{$options.TitleName}}.{{Title $options.GoType}}{{if and (eq $options.TitleName "ID") $model.IDIsUUID}}(){{end}})
		if (value == filter.Value && filter.Include) || (value != filter.Value && !filter.Include) {
			ok, filterIsValid = true, true
		}{{end}}{{end}}
	default:
		ok, filterIsValid = true, false
	}
	return
}

func app{{$modelName}}(m {{$modelName}}) *app.{{$modelName}} {
	return &app.{{$modelName}}{ {{range $name, $options := $model.Columns}}
		{{$options.TitleName}}: {{if $options.IsStruct}}app{{$options.GoType}}{{if $options.IsArray}}s{{end}}(m.{{$options.TitleName}}){{else}}m.{{$options.TitleName}}{{if eq $options.TitleName "ID"}}{{if $model.IDIsUUID}}.String(){{end}}{{else}}.{{Title $options.GoType}}{{end}}{{end}}, {{end}}
	}
}

func app{{$modelName}}s(ms []{{$modelName}}) []*app.{{$modelName}} {
	ams := []*app.{{$modelName}}{}
	for _, m := range ms {
		ams = append(ams, app{{$modelName}}(m))
	}

	return ams
}

{{- $modelName := .CurModel}}
{{- $model := (index $.Models $modelName)}}
{{- $models := .Models}}
{{- $haveNestedSorts := false}}
{{- range $_, $opts := $model.Columns}}
	{{- if $opts.NestedSorts}}
		{{- $haveNestedSorts = true}}
	{{- end}}
{{- end}}
// Code generated by mtgroup-generator.
package dal

import (
	"database/sql"
	"strings"
{{- if and $model.HaveListMethod $haveNestedSorts}}
	"sort"
{{- end}}
{{- if or $model.HaveCreatedAt $model.HaveModifiedAt (ContainsStr $model.Methods "Delete") (ContainsStr $model.Methods "DeleteMy")}}
	"time"
{{- end}}
{{- if HaveListWithWarn $model}}
	"fmt"
{{- end}}
{{- if or $model.HaveJSON (HaveColumnWithModelThatIsStructAndIsArray $model.Columns $.Models false true)}}
	"encoding/json"
{{- end}}

	"{{.Module}}/internal/app"
{{- if $model.NeedTypes}}
	"{{.Module}}/internal/types"
{{- end}}

{{- if or $model.IDIsUUID (ContainsStr $model.Methods "AddMy")}}
	"github.com/google/uuid"
{{- else}}
	{{- $inputed := false}}
	{{- range $name, $options := $model.Columns}}
		{{- $model2 := (index $.Models $options.GoType)}}
		{{- if and $model2.IDIsUUID (not $inputed) (not $options.IsArray)}}
	"github.com/google/uuid"
			{{- $inputed = true}}
		{{- end}}
	{{- end}}
{{- end}}
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

type {{$modelName}} struct { 
{{- range $i, $psqlParams := $model.Psql}}
	{{- if $psqlParams.IsStruct}}
		{{- if not $psqlParams.IsArray}}
			{{$psqlParams.Name}}ID {{if eq  $psqlParams.TypeSQL "uuid"}}sql.NullString{{else}}sql.NullInt64{{end}} `db:"{{$psqlParams.SQLName}}"`
		{{- end}}
		{{$psqlParams.Name}} {{if $psqlParams.IsArray}}[]{{end}}{{$psqlParams.Type}}
	{{- else}}
		{{- if $psqlParams.IsCustom}}
			{{$psqlParams.Name}}JSON []byte `db:"{{$psqlParams.SQLName}}"`
			{{$psqlParams.Name}} {{if $psqlParams.IsArray}}[]{{end}}app.{{$psqlParams.Type}} 
		{{- else}}
			{{- if not $psqlParams.IsArray}}
				{{$psqlParams.Name}} {{if eq  $psqlParams.TypeSQL "uuid"}}uuid.UUID{{else}}{{DalType $psqlParams.Type}}{{end}} `db:"{{$psqlParams.SQLName}}"` 
			{{- else}}
				{{$psqlParams.Name}}JSON []byte `db:"{{$psqlParams.SQLName}}"`
				{{$psqlParams.Name}} []{{$psqlParams.Type}} 
			{{- end}}
		{{- end}}
	{{- end}}
{{- end}}
}

{{- range $i, $method := $model.Methods}}
{{- if not (IsCustomMethod $method)}}
	{{- if IsGet $method}}
	func (a *App) {{$method}}{{$modelName}}({{if not $model.BoundToIsolatedEntity}}{{if IsMyMethod $method}}profileID{{else}}id{{end}} {{if $model.IDIsUUID}}string{{else}}int64{{end}}{{end}}{{if not $model.Shared}}{{if not $model.BoundToIsolatedEntity}}, {{end}}isolatedEntityID string{{end}}) (*app.{{$modelName}}, error) { 
		{{- if IsMyMethod $method}}
			id, err := a.getMy{{$modelName}}ID({{if not $model.BoundToIsolatedEntity}}profileID{{end}}{{if not $model.Shared}}{{if not $model.BoundToIsolatedEntity}}, {{end}}isolatedEntityID{{end}})
			if err != nil {
				return nil, err
			}
		{{- end}}
		return a.get{{$modelName}}(id{{if not $model.Shared}}, isolatedEntityID{{end}})
	}
	{{- end}}
	{{- if IsAdd $method}}
	func (a *App) {{$method}}{{$modelName}}(profileID string, {{if not $model.Shared}}isolatedEntityID string, {{end}}m *app.{{$modelName}}) (*app.{{$modelName}}, error) {
		{{- if IsMyMethod $method}}
			_, err := a.getMy{{$modelName}}ID({{if not $model.BoundToIsolatedEntity}}profileID{{end}}{{if not $model.Shared}}{{if not $model.BoundToIsolatedEntity}}, {{end}}isolatedEntityID{{end}})
			if err == nil {
				return nil, app.ErrDuplicateID
			}
			if err != nil && err != app.ErrNotFound {
				return nil, err
			}
		{{- end}}
		id, err := a.add{{$modelName}}(profileID, {{if not $model.Shared}}isolatedEntityID, {{end}}m)
		if err != nil {
			return nil, err
		}
		{{- if IsMyMethod $method}}
			err = a.bindTo{{if $model.BoundToIsolatedEntity}}IsolatedEntity{{else}}Profile{{end}}{{$modelName}}(id{{if not $model.BoundToIsolatedEntity}}, profileID{{end}}{{if not $model.Shared}}, isolatedEntityID{{end}})
			if err != nil {
				return nil, err
			}
		{{- end}}
		return a.get{{$modelName}}(id{{if not $model.Shared}}, isolatedEntityID{{end}})
	}
	{{- end}}
	{{- if IsDelete $method}}
	func (a *App) {{$method}}{{$modelName}}({{if not (IsMyMethod $method)}}id {{if $model.IDIsUUID}}string{{else}}int64{{end}}, {{end}}profileID string{{if not $model.Shared}}, isolatedEntityID string{{end}}) error {
		{{- if IsMyMethod $method}}
			id, err := a.getMy{{$modelName}}ID({{if not $model.BoundToIsolatedEntity}}profileID{{end}}{{if not $model.Shared}}{{if not $model.BoundToIsolatedEntity}}, {{end}}isolatedEntityID{{end}})
			if err != nil {
				return err
			}
		{{- end}}
		res, err := a.db.Exec(`UPDATE {{NameSQL $modelName}}s SET deleted=true, deleted_at=$2, deleted_by=$3 WHERE id=$1{{if not $model.Shared}} AND isolated_entity_id=$4{{end}} AND NOT deleted`, id, time.Now().Format(time.RFC3339), profileID{{if not $model.Shared}}, isolatedEntityID{{end}})
		if err != nil {
			return err
		}
		if count, _ := res.RowsAffected(); count == 0 {
			return app.ErrNotFound
		}
		
		return nil
	}
	{{- end}}
	{{- if IsEdit $method}}
	func (a *App) {{$method}}{{$modelName}}({{if not (IsMyMethod $method)}}id {{if $model.IDIsUUID}}string{{else}}int64{{end}}, {{end}}{{if or (and (IsMyMethod $method) (not $model.BoundToIsolatedEntity)) $model.HaveModifiedBy}}profileID string, {{end}}{{if not $model.Shared}}isolatedEntityID string, {{end}}m *app.{{$modelName}}) {{if $model.ReturnWhenEdit}}(*app.{{$modelName}}, error){{else}}error{{end}}  {
		{{- if IsMyMethod $method}}
			id, err := a.getMy{{$modelName}}ID({{if not $model.BoundToIsolatedEntity}}profileID{{end}}{{if not $model.Shared}}{{if not $model.BoundToIsolatedEntity}}, {{end}}isolatedEntityID{{end}})
			if err != nil{{if eq $method "EditOrAddMy"}} && err != app.ErrNotFound{{end}} {
				return {{if $model.ReturnWhenEdit}}nil, {{end}}err
			}
		{{- end}}
		{{- range $column, $options := $model.Columns}}
			{{- if or (not (IsCustomEdit $method)) (and (ContainsStr (index $model.MethodsProps $i).EditableFields $column) (IsCustomEdit $method))}}
				{{- if and $options.IsStruct (not $options.IsArray)}}
					var {{$column}}ID interface{}
					if m.{{$options.TitleName}} != nil {
						{{$column}}ID = m.{{$options.TitleName}}.ID
					}
				{{- end}}
				{{- if or (and $options.IsArray (not $options.IsStruct)) $options.IsCustom}}
					{{$options.TitleName}}JSON, _ := json.Marshal(m.{{$options.TitleName}})
				{{- end}}
			{{- end}}
		{{- end}}
		{{- if $model.HaveModifiedAt}}
			m.ModifiedAt = time.Now().Format(time.RFC3339)
		{{- end}}
		{{- if $model.HaveModifiedBy}}
			m.ModifiedBy = profileID
		{{- end}}

		res, err := a.db.Exec(`UPDATE {{NameSQL $modelName}}s SET {{if  (IsCustomEdit $method)}}{{(index $model.MethodsProps $i).CustomSQLEditStr}}{{else}}{{$model.SQLEditStr}}{{end}} WHERE id=$1{{if not $model.Shared}} AND isolated_entity_id=$2{{end}} AND NOT deleted`, id{{if not $model.Shared}}, isolatedEntityID{{end}}, {{if  (IsCustomEdit $method)}}{{(index $model.MethodsProps $i).CustomSQLExecParams}}{{else}}{{$model.SQLEditExecParams}}{{end}})
		if err != nil {
			return {{if $model.ReturnWhenEdit}}nil, {{end}}err
		}

		if count, _ := res.RowsAffected(); count == 0 {
			{{- if eq $method "EditOrAddMy"}}
				_, err := a.add{{$modelName}}({{if $model.IDIsUUID}}id, {{end}}{{if $model.HaveCreatedBy}}id, {{end}}{{if not $model.Shared}}isolatedEntityID, {{end}}m)
				if err != nil {
					return {{if $model.ReturnWhenEdit}}nil, {{end}}err
				}
			{{- else}}
				return {{if $model.ReturnWhenEdit}}nil, {{end}}app.ErrNotFound
			{{- end}}
		}

		return {{if $model.ReturnWhenEdit}}a.get{{$modelName}}(id{{if not $model.Shared}}, isolatedEntityID{{end}}){{else}}nil{{end}}
	}
	{{- end}}
	{{- if IsList $method}}
	func (a *App) {{$method}}{{$modelName}}({{if not $model.Shared}}isolatedEntityID string, {{end}}offset, limit int64, filters []*app.Filter, logicFilter bool, sortBy, orderBy string) ([]*app.{{$modelName}}, {{if $model.DetailedPagination}} int,{{end}}[]string, error) { 
		ms := []{{$modelName}}{}
		warnings := []string{}

		var orderQuery string 
		{{- if $haveNestedSorts}}
			var nestedSort bool
		{{- end}}
		switch sortBy {
			{{- range $column, $options := $model.Columns }}
				{{- if and $options.SortOn (not $options.IsStruct) }}
					case "{{$column}}":
						orderQuery = "ORDER BY {{NameSQL $column}}"
				{{- end}}
			{{- end}}
			default:
				{{- $completeIfStmt := false }}
				{{- range $column, $options := $model.Columns}}
					{{- if $options.SortDefault }}
						{{/* {{- if $haveNestedSorts }} */}}
							{{- $completeIfStmt = true }}
							if sortBy == "" { 
						{{/* {{- end}} */}}
								orderQuery = "ORDER BY {{NameSQL $column}}"
						{{- if $options.SortOrderDefault}}
								if orderBy == "" {
									orderBy = "{{$options.SortOrderDefault}}"
								}
						{{- end }}
					{{- end }}
				{{- end }}
				{{- if and $haveNestedSorts $completeIfStmt}}
							} else {
								nestedSort = true
				{{- end}}
				{{- if and $haveNestedSorts (not $completeIfStmt)}}
								nestedSort = true
				{{- end}}
				{{- if $completeIfStmt}}
							}
				{{- end}}
		}

		if orderQuery != "" {
			switch orderBy {
			case "ASC", "":
				orderQuery += " ASC"
			case "DESC":
				orderQuery += " DESC"
			}
		}

		mapQuery := map[string]interface{}{ 
			{{- if IsCustomList $method}}
				{{- range $_, $column := (index $model.MethodsProps $i).FilteredFields}}
					{{- if not (index (index $model.MethodsProps $i).ArrayColumns $column)}}
						"{{$column}}": nil,
						"not_{{$column}}": nil,
					{{- end}}
				{{- end}}
			{{- else}}
				{{- range $column, $options := $model.Columns}}
					{{- if not $options.IsArray}}
						"{{$column}}": nil,
						"not_{{$column}}": nil,
					{{- end}}
				{{- end}}
			{{- end}}
			{{- if not $model.Shared}}
				"isolated_entity_id": isolatedEntityID,
			{{- end}}
		}

		{{- if NeedCustomFilter $model $method}}
			customFilters := []*app.Filter{}
		{{- end}}

		{{- if or (index $model.MethodsProps $i).FilteredFields (not (IsCustomList $method))}}
			if logicFilter {
				for _, filter := range filters {
					switch filter.Key { 
				{{- if IsCustomList $method}}
					{{- range $_, $column := (index $model.MethodsProps $i).FilteredFields}}
						{{- if not (index (index $model.MethodsProps $i).ArrayColumns $column)}}
						case "{{$column}}":
							if filter.Include {
								mapQuery["{{$column}}"] = {{if IsNotStrictFilter $model $column}}"%%" + {{end}}filter.Value{{if IsNotStrictFilter $model $column}} + "%%"{{end}}
							} else {
								mapQuery["not_{{$column}}"] = {{if IsNotStrictFilter $model $column}}"%%" + {{end}}filter.Value{{if IsNotStrictFilter $model $column}} + "%%"{{end}}
							}
						{{- end}}
					{{- end}}
				{{- else}}
					{{- range $column, $options := $model.Columns}}
						{{- if not $options.IsArray}}
						case "{{$column}}":
							if filter.Include {
								mapQuery["{{$column}}"] = {{if IsNotStrictFilter $model $column}}"%%" + {{end}}filter.Value{{if IsNotStrictFilter $model $column}} + "%%"{{end}}
							} else {
								mapQuery["not_{{$column}}"] = {{if IsNotStrictFilter $model $column}}"%%" + {{end}}filter.Value{{if IsNotStrictFilter $model $column}} + "%%"{{end}}
							}
						{{- end}}
					{{- end}}
				{{- end}}
					default:
						customFilters = append(customFilters, filter)
					}
				}
			} else {
				for _, filter := range filters {
					customFilters = append(customFilters, filter)
				}
			}
		{{- end}}
		
		rows, err := a.db.NamedQuery(`SELECT {{if  (IsCustomList $method)}}{{(index $model.MethodsProps $i).CustomListSQLSelect}}{{else}}{{$model.SQLSelectStr}}{{end}} FROM {{NameSQL $modelName}}s {{if or (index $model.MethodsProps $i).FilteredFields (not (IsCustomList $method))}}WHERE {{end}}{{if  (IsCustomList $method)}}{{(index $model.MethodsProps $i).CustomListSQLWhereProps}}{{else}}{{$model.SQLWhereParams}}{{end}} {{if not $model.Shared}}{{if or (index $model.MethodsProps $i).FilteredFields (not (IsCustomList $method))}}AND{{else}}WHERE{{end}} isolated_entity_id=:isolated_entity_id{{end}} AND NOT deleted ` + orderQuery, mapQuery)
		if err != nil {
			return nil,{{if $model.DetailedPagination}} -1,{{end}} nil, err
		}
		for rows.Next() {
			var m {{$modelName}}
			err = rows.StructScan(&m)
			ms = append(ms, m)
		}

		{{- if or (and (not (IsCustomList $method)) $model.HaveJSON) (and (IsCustomList $method) (index $model.MethodsProps $i).HaveJSON)}}
			for i := range ms { 
			{{- range $column, $options := $model.Columns}}
				{{- if or (and (or (and $options.IsArray (not $options.IsStruct)) $options.IsCustom) (not (IsCustomList $method))) (and (IsCustomList $method) (index (index $model.MethodsProps $i).ArrayColumns $column))}}
					if err := json.Unmarshal(ms[i].{{$options.TitleName}}JSON, &ms[i].{{$options.TitleName}}); err != nil {
						return nil,{{if $model.DetailedPagination}} -1,{{end}} nil, err
					}
				{{- end}}
			{{- end}}
			}
		{{- end}}
		
		result := []{{$modelName}}{}
		{{- if $model.HaveLazyLoading}}
			{{- if (IsCustomList $method)}}
				{{- if or ((index $model.MethodsProps $i).NeedLazyLoading) ((index $model.MethodsProps $i).HaveJSON)}}
					for i := range ms {
					{{- if (index $model.MethodsProps $i).NeedLazyLoading}}
						if err := ms[i].LazyLoading{{$method}}({{if not $model.Shared}}isolatedEntityID, {{end}}a); err != nil {
							return nil,{{if $model.DetailedPagination}} -1,{{end}} nil, err
						}
					{{- end}}
						ok := true
						for j := 0; j < len(customFilters); j++ {
							var validFilter bool
							filterKey := customFilters[j].Key
						{{- if (index $model.MethodsProps $i).NeedLazyLoading}}
							if !logicFilter && !strings.Contains(customFilters[j].Key, ".") {
								ok, validFilter = ms[i].Filter(customFilters[j])
							} else {
								ok, validFilter = ms[i].NestedFilter(customFilters[j])
							}
						{{- else}}
							ok, validFilter = ms[i].Filter(customFilters[j])
						{{- end}}
							customFilters[j].Key = filterKey
							if !validFilter {
								warnings = append(warnings, fmt.Sprintf("filter key '%s' is not valid", customFilters[j].Key))
								customFilters = append(customFilters[:j], customFilters[j+1:]...)
								j--
							}
							if (!ok && logicFilter) || (ok && !logicFilter) {
								break
							}
						}
						if ok {
							result = append(result, ms[i])
						}
					}
				{{- else}}
					result = ms
				{{- end}}
			{{- else}}
				for i := range ms {
					if err := ms[i].LazyLoading({{if not $model.Shared}}isolatedEntityID, {{end}}a); err != nil {
						return nil,{{if $model.DetailedPagination}} -1,{{end}} nil, err
					}
					ok := true
					for j := 0; j < len(customFilters); j++ {
						var validFilter bool
						filterKey := customFilters[j].Key
					{{- if $model.HaveLazyLoading}}
						if !logicFilter && !strings.Contains(customFilters[j].Key, ".") {
							ok, validFilter = ms[i].Filter(customFilters[j])
						} else {
							ok, validFilter = ms[i].NestedFilter(customFilters[j])
						}
					{{- else}}
						ok, validFilter = ms[i].Filter(customFilters[j])
					{{- end}}
						customFilters[j].Key = filterKey
						if !validFilter {
							warnings = append(warnings, fmt.Sprintf("filter key '%s' is not valid", customFilters[j].Key))
							customFilters = append(customFilters[:j], customFilters[j+1:]...)
							j--
						}
						if (!ok && logicFilter) || (ok && !logicFilter) {
							break
						}
					}
					if ok {
						result = append(result, ms[i])
					}
				}
			{{- end}}
		{{- else}}
			for i := range ms {
				ok := true
				for j := 0; j < len(customFilters); j++ {
					var validFilter bool
					ok, validFilter = ms[i].Filter(customFilters[j])
					if !validFilter {
						warnings = append(warnings, fmt.Sprintf("filter key '%s' is not valid", customFilters[j].Key))
						customFilters = append(customFilters[:j], customFilters[j+1:]...)
						j--
					}
					if (!ok && logicFilter) || (ok && !logicFilter) {
						break
					}
				}
				if ok {
					result = append(result, ms[i])
				}
			}
		{{- end}}
		{{- if $haveNestedSorts}}
			if nestedSort {
				var orderByASC bool
				switch orderBy {
				case "ASC", "":
					orderByASC = true
				case "DESC":
					orderByASC = false
				}
				switch sortBy { 
			{{- range $column, $options := $model.Columns}}
				{{- range $j, $sort := $options.SortBy}}
				case "{{$column}}.{{$sort}}":
					if orderByASC {
						sort.Slice({{if $model.HaveLazyLoading}}result{{else}}ms{{end}}, func(i, j int) bool { return {{if $model.HaveLazyLoading}}result{{else}}ms{{end}}[i]{{index $options.NestedSorts $j}} < {{if $model.HaveLazyLoading}}result{{else}}ms{{end}}[j]{{index $options.NestedSorts $j}} })
					} else {
						sort.Slice({{if $model.HaveLazyLoading}}result{{else}}ms{{end}}, func(i, j int) bool { return {{if $model.HaveLazyLoading}}result{{else}}ms{{end}}[i]{{index $options.NestedSorts $j}} >= {{if $model.HaveLazyLoading}}result{{else}}ms{{end}}[j]{{index $options.NestedSorts $j}} })
					}
				{{- end}}
			{{- end}}
				default:
					warnings = append(warnings, fmt.Sprintf("sorting by '%s' is not avaliable or '%s' is not a valid sort key", sortBy, sortBy))
				}
			}
		{{- end}}

		start, end := pagination(int(offset), int(limit), len(result))

		return app{{$modelName}}s(result[start:end]),{{if $model.DetailedPagination}} len(result),{{end}} warnings, nil
	}
	{{- end}}

	{{- if and (IsCustomList $method) ((index $model.MethodsProps $i).NeedLazyLoading)}}
		{{- range $j, $nestedObj := (index $model.MethodsProps $i).NestedObjs}}
		{{- if $nestedObj.IsFirstForLazyLoading}}
			func (m *{{if $nestedObj.Path}}{{$nestedObj.ParentStruct}}{{else}}{{$modelName}}{{end}})LazyLoading{{$method}}{{$nestedObj.Path}}({{if $nestedObj.Path}}{{if not  (index $.Models $nestedObj.ParentStruct).Shared}} isolatedEntityID string, {{end}}{{else}}{{if not $model.Shared}}isolatedEntityID string, {{end}}{{end}}a *App) (err error) { 
		{{- end}} 
			{{- $model2 := (index $.Models $nestedObj.Type)}}
			{{- if  $nestedObj.IsArray}}
				{{- $sliceName := (print "slice" $nestedObj.Name)}}
				{{$sliceName}} := []{{if $nestedObj.Path}}{{$nestedObj.ParentStruct}}{{else}}{{$modelName}}{{end}}{{$nestedObj.Type}}{}
				if err = a.db.Select(&{{$sliceName}}, `SELECT {{if $nestedObj.Path}}{{NameSQL $nestedObj.ParentStruct}}{{else}}{{NameSQL $modelName}}{{end}}_id, {{NameSQL $nestedObj.Name}}_id FROM {{if $nestedObj.Path}}{{NameSQL $nestedObj.ParentStruct}}{{else}}{{NameSQL $modelName}}{{end}}_{{NameSQL $nestedObj.Name}} WHERE {{if $nestedObj.Path}}{{NameSQL $nestedObj.ParentStruct}}{{else}}{{NameSQL $modelName}}{{end}}_id=$1{{if not $model2.Shared}} AND isolated_entity_id=$2{{end}}`, m.ID{{if not $model2.Shared}}, isolatedEntityID{{end}}); err != nil {
					return
				}
				for _, cd := range {{$sliceName}} {
					var elem {{$nestedObj.Type}}
					if err = a.db.Get(&elem, `SELECT {{$nestedObj.SQLSelect}} FROM {{NameSQL $nestedObj.Type}}s WHERE id=$1{{if not $model2.Shared}} AND isolated_entity_id=$2{{end}}`, cd.{{$nestedObj.Type}}ID{{if not $model2.Shared}}, isolatedEntityID{{end}}); err != nil {
						return
					}
					{{- if $nestedObj.NeedLazyLoading}}
						if err == nil {
							if err = elem.LazyLoading{{$method}}{{$nestedObj.Path}}{{$nestedObj.Name}}({{if not $model2.Shared}}isolatedEntityID, {{end}}a); err != nil {
								return
							}
						}
					{{- end}}
					m.{{$nestedObj.Name}} = append(m.{{$nestedObj.Name}}, elem)
				}
			{{- else}}
				if err = a.db.Get(&m.{{$nestedObj.Name}}, `SELECT {{$nestedObj.SQLSelect}} FROM {{NameSQL $nestedObj.Type}}s WHERE id=$1{{if not $model2.Shared}} AND isolated_entity_id=$2{{end}}`, m.{{$nestedObj.Name}}ID{{if not $model2.Shared}}, isolatedEntityID{{end}}); err != nil && err != sql.ErrNoRows {
					return
				}
				{{- if $nestedObj.NeedLazyLoading}}
				if err == nil {
					if err = m.{{$nestedObj.Name}}.LazyLoading{{$method}}{{$nestedObj.Name}}({{if not $model2.Shared}}isolatedEntityID, {{end}}a); err != nil {
						return
					}
				}
				{{- end}}
			{{- end}}
		{{- if $nestedObj.IsLastForLazyLoading}}
				return nil
			}
		{{- end}}
		{{- end}}
	{{- end}}
{{end}}
{{- end}}

{{- if $model.HaveLazyLoading}}
func (m *{{$modelName}}) LazyLoading({{if not $model.Shared}}isolatedEntityID string, {{end}}a *App) (err error) { 
{{- range $modelName2, $model2 := $.Models}}
	{{- range $column, $options := $model.Columns}}
		{{- if eq $modelName2 $options.GoType}}
			{{- if and $options.IsArray $options.IsStruct}}
				slice{{$options.TitleName}} := []{{$modelName}}{{$options.GoType}}{}
				if err = a.db.Select(&slice{{$options.TitleName}}, `SELECT {{NameSQL $modelName}}_id, {{NameSQL $options.TitleName}}_id FROM {{NameSQL $modelName}}_{{NameSQL $options.TitleName}} WHERE {{NameSQL $modelName}}_id=$1{{if not $model2.Shared}} AND isolated_entity_id=$2{{end}}`, m.ID{{if not $model2.Shared}}, isolatedEntityID{{end}}); err != nil {
					return
				}
				for _, cd := range slice{{$options.TitleName}} {
					var {{$column}} {{$options.GoType}}
					if err = a.db.Get(&{{$column}}, `SELECT {{$model2.SQLSelectStr}} FROM {{NameSQL $options.GoType}}s WHERE id=$1{{if not $model2.Shared}} AND isolated_entity_id=$2{{end}}`, cd.{{$options.GoType}}ID{{if not $model2.Shared}}, isolatedEntityID{{end}}); err != nil {
						return
					}
					{{- range $column2, $options2 := $model2.Columns}}
						{{- if  or (and $options2.IsArray (not $options2.IsStruct)) $options2.IsCustom}}
							if err = json.Unmarshal({{$column}}.{{$options2.TitleName}}JSON, &{{$column}}.{{$options2.TitleName}}); err != nil {
								return
							}
						{{- end}}
					{{- end}}
					{{- if $model2.HaveLazyLoading}}
						if err == nil {
							if err = {{$column}}.LazyLoading({{if not $model2.Shared}}isolatedEntityID, {{end}}a); err != nil {
								return
							}
						}
					{{- end}}
					m.{{$options.TitleName}} = append(m.{{$options.TitleName}}, {{$column}})
				}
			{{- else}}
				if err = a.db.Get(&m.{{$options.TitleName}}, `SELECT {{$model2.SQLSelectStr}} FROM {{NameSQL $modelName2}}s WHERE id=$1{{if not $model2.Shared}} AND isolated_entity_id=$2{{end}}`,  m.{{$options.TitleName}}ID{{if not $model2.Shared}}, isolatedEntityID{{end}}); err != nil && err != sql.ErrNoRows {
					return
				}
				{{- range $column2, $options2 := $model2.Columns}}
					{{- if  or (and $options2.IsArray (not $options2.IsStruct)) $options2.IsCustom}}
						if err != sql.ErrNoRows {
							if err = json.Unmarshal(m.{{$options.TitleName}}.{{$options2.TitleName}}JSON, &m.{{$options.TitleName}}.{{$options2.TitleName}}); err != nil {
								return
							}
						}
					{{- end}}
				{{- end}}
				{{- if $model2.HaveLazyLoading}}
					if err == nil {
						if err = m.{{$options.TitleName}}.LazyLoading({{if not $model2.Shared}}isolatedEntityID, {{end}}a); err != nil {
							return
						}
					}
				{{- end}}
			{{- end}}
		{{- end}}
	{{- end}}
{{- end}}
	return nil
}
{{- end}}

{{- range $column, $options := $model.Columns}}
{{- if  and $options.IsArray $options.IsStruct}}
	func (a *App) Add{{Title $column}}{{$modelName}}(id {{if $model.IDIsUUID}}string{{else}}int64{{end}}, {{if $model.HaveModifiedBy}}profileID string, {{end}}{{if not $model.Shared}}isolatedEntityID string, {{end}}itemsID []{{if (index $.Models $options.GoType).IDIsUUID}}string{{else}}int64{{end}}, items []*app.{{$options.GoType}}) error {
		for _, item := range items {
			{{- $model2 := (index $.Models $options.GoType)}}
			id, err := a.add{{$options.GoType}}({{if $model2.IDIsUUID}}uuid.New().String(), {{end}}{{if not $model2.Shared}}isolatedEntityID, {{end}}item)
			if err != nil {
				return err
			}
			itemsID = append(itemsID, id)
		}
		for _, itemID := range itemsID {
			if _, err := a.db.Exec(`INSERT INTO {{NameSQL $modelName}}_{{NameSQL $column}}({{NameSQL $modelName}}_id, {{NameSQL $column}}_id{{if not $model.Shared}}, isolated_entity_id{{end}}) VALUES ($1, $2{{if not $model.Shared}}, $3{{end}})`, id, itemID{{if not $model.Shared}}, isolatedEntityID{{end}}); err != nil {
				if strings.Contains(err.Error(), "violates foreign key constraint") {
					switch {
					case strings.Contains(err.Error(), "{{NameSQL $modelName}}_id_fkey"):
						return app.ErrNotFound
					case strings.Contains(err.Error(), "{{NameSQL $column}}_id_fkey"):
						return app.ErrNotFoundArrayItem
					}
				}
				return err
			}
		}
	{{- if or $model.HaveModifiedAt $model.HaveModifiedBy}}
		{{- $countParams := 2}}
		{{- if not $model.Shared}}
			{{- $countParams = 3}}
		{{- end}}
		if _, err := a.db.Exec(`UPDATE {{NameSQL $modelName}}s SET {{if $model.HaveModifiedAt}}modified_at=${{$countParams}}{{$countParams = 4}}{{end}}{{if $model.HaveModifiedBy}}modified_by=${{$countParams}}{{end}} WHERE id=$1{{if not $model.Shared}} AND isolated_entity_id=$2{{end}}`, id{{if not $model.Shared}}, isolatedEntityID{{end}}{{if $model.HaveModifiedAt}}, time.Now().Format(time.RFC3339){{end}}{{if $model.HaveModifiedBy}}, profileID{{end}}); err != nil {
			return {{if $model.ReturnWhenEdit}}nil, {{end}}err
		}
	{{- end}}
		return nil
	}

	func (a *App) Delete{{Title $column}}{{$modelName}}(id {{if $model.IDIsUUID}}string{{else}}int64{{end}}, {{if $model.HaveModifiedBy}}profileID string, {{end}}{{if not $model.Shared}}isolatedEntityID string, {{end}}items []{{if (index $.Models $options.GoType).IDIsUUID}}string{{else}}int64{{end}}) error {
		for _, item := range items {
			res, err := a.db.Exec(`DELETE FROM {{NameSQL $modelName}}_{{NameSQL $column}} WHERE {{NameSQL $modelName}}_id=$1 AND {{NameSQL $column}}_id=$2{{if not $model.Shared}} AND isolated_entity_id=$3{{end}}`, id, item{{if not $model.Shared}}, isolatedEntityID{{end}})
			if err != nil {
				return err
			}
			if count, _ := res.RowsAffected(); count == 0 {
				return app.ErrNotFound
			}
		}
	{{- if or $model.HaveModifiedAt $model.HaveModifiedBy}}
		{{- $countParams := 2}}
		{{- if not $model.Shared}}
			{{- $countParams = 3}}
		{{- end}}
		if _, err := a.db.Exec(`UPDATE {{NameSQL $modelName}}s SET {{if $model.HaveModifiedAt}}modified_at=${{$countParams}}{{$countParams = 4}}{{end}}{{if $model.HaveModifiedBy}}modified_by=${{$countParams}}{{end}} WHERE id=$1{{if not $model.Shared}} AND isolated_entity_id=$2{{end}}`, id{{if not $model.Shared}}, isolatedEntityID{{end}}{{if $model.HaveModifiedAt}}, time.Now().Format(time.RFC3339){{end}}{{if $model.HaveModifiedBy}}, profileID{{end}}); err != nil {
			return err
		}
	{{- end}}
		return nil
	}
{{- end}}
{{- end}}

func (a *App) {{$modelName}}AccessManager(am *app.AccessManager) error {
	if _, err := a.db.Exec(`INSERT INTO {{NameSQL $modelName}}s_access VALUES ($1, $2, $3, $4, $5, $6, $7)`, am.User, am.Group, am.Read, am.Write, am.Delete, am.Add, am.AccessManager); err != nil {
		return err
	}
	return nil
}

func (a *App) get{{$modelName}}(id {{if $model.IDIsUUID}}string{{else}}int64{{end}}{{if not $model.Shared}}, isolatedEntityID string{{end}}) (*app.{{$modelName}}, error) { 
	var m {{$modelName}}
	if err := a.db.Get(&m, `SELECT {{$model.SQLSelectStr}} FROM {{NameSQL $modelName}}s WHERE id=$1{{if not $model.Shared}} AND isolated_entity_id=$2{{end}} AND NOT deleted`, id{{if not $model.Shared}}, isolatedEntityID{{end}}); err != nil {
		if err == sql.ErrNoRows {
			return nil, app.ErrNotFound
		} 
		return nil, err
	}
	{{- range $column, $options := $model.Columns}}
		{{- if  or (and $options.IsArray (not $options.IsStruct)) $options.IsCustom}}
			if err := json.Unmarshal(m.{{$options.TitleName}}JSON, &m.{{$options.TitleName}}); err != nil {
				return nil, err
			}
		{{- end}}
	{{- end}}
	{{- if $model.HaveLazyLoading}}
		if err := m.LazyLoading({{if not $model.Shared}}isolatedEntityID, {{end}}a); err != nil {
			return nil, err
		}
	{{- end}}
	return app{{$modelName}}(m), nil
}

func (a *App) add{{$modelName}}(profileID string, {{if not $model.Shared}}isolatedEntityID string, {{end}}m *app.{{$modelName}}) ({{if $model.IDIsUUID}}string{{else}}int64{{end}}, error) {
	{{- if $model.IDIsUUID}}
		{{$modelName}}ID := uuid.New().String()
	{{- else}}
		var {{$modelName}}ID int64
	{{- end}}
	{{- if $model.HaveCreatedAt}}
		m.CreatedAt = time.Now().Format(time.RFC3339)
	{{- end}}
	{{- range $column, $options := $model.Columns}}
		{{- if and $options.IsStruct (not $options.IsArray)}}
			var {{$column}}ID interface{}
			if m.{{$options.TitleName}} != nil {
				{{$column}}ID = m.{{$options.TitleName}}.ID
			}
		{{- end}}
		{{- if  or (and $options.IsArray (not $options.IsStruct)) $options.IsCustom}}
			{{$options.TitleName}}JSON, _ := json.Marshal(m.{{$options.TitleName}})
		{{- end}}
	{{- end}}
	if err := a.db.Get(&{{$modelName}}ID, `INSERT INTO {{NameSQL $modelName}}s{{$model.SQLAddStr}} RETURNING id`, {{$model.SQLAddExecParams}}{{if $model.IDIsUUID}}, {{$modelName}}ID{{end}}{{if not $model.HaveCreatedBy}}, profileID{{end}}{{if not $model.Shared}}, isolatedEntityID{{end}}); err != nil {
		if strings.Contains(err.Error(), "duplicate key value violates unique constraint") {
			return {{if $model.IDIsUUID}}""{{else}}0{{end}}, app.ErrDuplicateID
		}
		return {{if $model.IDIsUUID}}""{{else}}0{{end}}, err
	}
	{{- range $modelName2, $model2 := $.Models}}
		{{- range $column, $options := $model.Columns}}
			{{- if eq $modelName2 $options.GoType}}
				{{- if and $options.IsArray $options.IsStruct}}
					for _, m := range m.{{$options.TitleName}} {
						if _, err := a.db.Exec(`INSERT INTO {{NameSQL $modelName}}_{{NameSQL $column}}({{NameSQL $modelName}}_id, {{NameSQL $column}}_id{{if not $model.Shared}}, isolated_entity_id{{end}}) VALUES ($1, $2{{if not $model.Shared}}, $3{{end}})`, {{$modelName}}ID, m.ID{{if not $model.Shared}}, isolatedEntityID{{end}}); err != nil {
							return {{if $model.IDIsUUID}}""{{else}}0{{end}}, err
						}
					}
				{{- end}}
			{{- end}}
		{{- end}}
	{{- end}}
	return {{$modelName}}ID{{if $model.IDIsUUID}}{{end}}, nil
}

func (a *App) getMy{{$modelName}}ID({{if not $model.BoundToIsolatedEntity}}profileID{{end}}{{if not $model.Shared}}{{if not $model.BoundToIsolatedEntity}}, {{end}}isolatedEntityID{{end}} string) (id string, err error) {
	if err = a.db.Get(&id, `SELECT id FROM {{NameSQL $modelName}}s WHERE {{if not $model.BoundToIsolatedEntity}}created_by=$1{{end}}{{if not $model.Shared}}{{if not $model.BoundToIsolatedEntity}} AND {{end}}isolated_entity_id=${{if $model.BoundToIsolatedEntity}}1{{else}}2{{end}}{{end}} AND NOT deleted AND bound`{{if not $model.BoundToIsolatedEntity}}, profileID{{end}}{{if not $model.Shared}}, isolatedEntityID{{end}}); err != nil {
		if err == sql.ErrNoRows {
			return "", app.ErrNotFound
		}
		return
	}
	return
}

func (a *App) bindTo{{if $model.BoundToIsolatedEntity}}IsolatedEntity{{else}}Profile{{end}}{{$modelName}}(id{{if not $model.BoundToIsolatedEntity}}, profileID{{end}}{{if not $model.Shared}}, isolatedEntityID{{end}} string) error {
	res, err := a.db.Exec(`UPDATE {{NameSQL $modelName}}s SET bound=true WHERE id=$1{{if not $model.BoundToIsolatedEntity}} AND created_by=$2{{end}}{{if not $model.Shared}} AND isolated_entity_id=${{if $model.BoundToIsolatedEntity}}2{{else}}3{{end}}{{end}} AND NOT deleted AND NOT bound`, id{{if not $model.BoundToIsolatedEntity}}, profileID{{end}}{{if not $model.Shared}}, isolatedEntityID{{end}})
	if err != nil {
		return err
	}

	if count, _ := res.RowsAffected(); count == 0 {
		return app.ErrNotFound
	}
	return nil
}

{{- range $functionName, $function := $.Functions}}
func (a *App) {{$functionName}}{{$modelName}}({{$function.InStrFull}}) ({{$function.OutStrType}}, error){
	{{- range $name, $type := $function.Out}}
		var {{$name}} {{$type}}
	{{- end}}
	/* Example:
	if err := a.db.Get(&key, `SELECT key FROM components WHERE title=$1`, serviceName); err != nil {
		return "", err
	}*/

	return {{$function.OutStr}}, nil
}
{{- end}}

{{- if $model.HaveLazyLoading}}
func (m *{{$modelName}}) NestedFilter(filter *app.Filter) (ok, filterIsValid bool) {
	if strings.Contains(filter.Key, ".") {
		splitedFilter := strings.SplitN(filter.Key, ".", 2)
		filter.Key = splitedFilter[1]
		switch splitedFilter[0] {
		{{- range $column, $options := $model.Columns}}
			{{- if and $options.IsStruct (not $options.IsArray)}}
			case "{{$column}}":
				ok, filterIsValid = m.{{$options.TitleName}}.{{if (index $models $options.GoType).HaveLazyLoading}}Nested{{end}}Filter(filter)
			{{- end}}
		{{- end}}
		default:
			ok, filterIsValid = true, false
		}
	} else {
		ok, filterIsValid = m.Filter(filter)
	}
	return
}
{{- end}}

func (m *{{$modelName}}) Filter(filter *app.Filter) (ok, filterIsValid bool) {
	switch filter.Key {
	{{- range $column, $options := $model.Columns}}
		{{- if not $options.IsStruct}}
		case "{{$column}}":
			{{- if $options.IsArray}}
			for _, elem := range m.{{$options.TitleName}} {
			{{- end}}
				{{- if $options.IsCustom}}
					{{- if $options.IsArray}}
						elemJSON, err := json.Marshal(elem)
						if err != nil {
							ok, filterIsValid = true, false
							return
						}
						equal, err := areEqualJSON(filter.Value, string(elemJSON))
					{{- else}}
						equal, err := areEqualJSON(filter.Value, string(m.CustJSON))
					{{- end}}
					if err != nil {
						ok, filterIsValid = true, false
						return
					}
				{{- else}}
					value := toString({{if $options.IsArray}}elem{{else}}m.{{$options.TitleName}}.{{if eq $options.GoType "types.Decimal"}}Decimal.String(){{else}}{{Title $options.GoType}}{{if and (eq $options.TitleName "ID") $model.IDIsUUID}}(){{end}}{{end}}{{end}})
					equal := {{if or (ne $options.Type "string") $options.StrictFilter}}value == filter.Value{{else}}contains(value, filter.Value){{end}}
				{{- end}}
				if (equal && filter.Include) || (!equal && !filter.Include) {
					ok, filterIsValid = true, true
				} else {
					ok, filterIsValid = false, true
				}
			{{- if $options.IsArray}}
			}
			{{- end}}
		{{- end}}
	{{- end}}
	default:
		ok, filterIsValid = true, false
	}
	return
}

func app{{$modelName}}(m {{$modelName}}) *app.{{$modelName}} {
	if {{if $model.IDIsUUID}}m.ID.String() == "00000000-0000-0000-0000-000000000000"{{else}}m.ID == 0{{end}} {
		return nil
	}
	return &app.{{$modelName}}{
		{{- range $name, $options := $model.Columns}}
			{{$options.TitleName}}: {{ConvertDalToAppColumn $options}},
		{{- end}}
	}
}

func app{{$modelName}}s(ms []{{$modelName}}) []*app.{{$modelName}} {
	ams := []*app.{{$modelName}}{}
	for _, m := range ms {
		ams = append(ams, app{{$modelName}}(m))
	}

	return ams
}

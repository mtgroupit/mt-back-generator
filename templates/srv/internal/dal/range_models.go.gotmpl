{{- $modelName := .CurModel}}
{{- $model := (index $.Models $modelName)}}
{{- $models := .Models}}
{{- $haveNestedSorts := false}}
{{- range $_, $opts := $model.Columns}}
	{{- if $opts.NestedSorts}}
		{{- $haveNestedSorts = true}}
	{{- end}}
{{- end}}
// Code generated by mtgroup-generator.
package dal

import (
	"database/sql"
	"strings"
{{- if and $model.HaveListMethod $haveNestedSorts}}
	"sort"
{{- end}}
{{- if or $model.HaveCreatedAt $model.HaveModifiedAt (ContainsStr $model.Methods "delete") (ContainsStr $model.Methods "deleteMy")}}
	"time"
{{- end}}
{{- if $model.HaveListMethod}}
	"fmt"
{{- end}}
{{- if or $model.HaveJSON (HaveColumnWithModelThatIsStructAndIsArray $model.Columns $.Models false true) (NeedJSONInsideColumns $model.Columns $.Models)}}
	"encoding/json"
{{- end}}

	"{{.Module}}/internal/app"
{{- if $model.NeedTypes}}
	"{{.Module}}/internal/types"
{{- end}}

{{- if or $model.IDIsUUID (ContainsStr $model.Methods "addMy")}}
	"github.com/google/uuid"
{{- else}}
	{{- $inputed := false}}
	{{- range $name, $options := $model.Columns}}
		{{- $model2 := (index $.Models $options.BusinessType)}}
		{{- if and $model2.IDIsUUID (not $inputed) (not $options.IsArray)}}
	"github.com/google/uuid"
			{{- $inputed = true}}
		{{- end}}
	{{- end}}
{{- end}}
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

type {{$modelName}} struct { 
{{- range $i, $psqlParams := $model.Psql}}
	{{- if $psqlParams.IsStruct}}
		{{- if not $psqlParams.IsArray}}
			{{$psqlParams.Name}}ID {{if eq  $psqlParams.TypeSQL "uuid"}}sql.NullString{{else}}sql.NullInt64{{end}} `db:"{{$psqlParams.SQLName}}"`
		{{- end}}
		{{$psqlParams.Name}} {{if $psqlParams.IsArray}}[]{{end}}{{$psqlParams.Type}}
	{{- else}}
		{{- if $psqlParams.IsCustom}}
			{{$psqlParams.Name}}JSON []byte `db:"{{$psqlParams.SQLName}}"`
			{{$psqlParams.Name}} {{if $psqlParams.IsArray}}[]{{end}}app.{{$psqlParams.Type}} 
		{{- else}}
			{{- if not $psqlParams.IsArray}}
				{{$psqlParams.Name}} {{if eq  $psqlParams.TypeSQL "uuid"}}uuid.UUID{{else}}{{DalType $psqlParams.Type}}{{end}} `db:"{{$psqlParams.SQLName}}"` 
			{{- else}}
				{{$psqlParams.Name}}JSON []byte `db:"{{$psqlParams.SQLName}}"`
				{{$psqlParams.Name}} []{{$psqlParams.Type}}
			{{- end}}
		{{- end}}
	{{- end}}
{{- end}}
}

var {{$modelName}}Props = map[string]columnProps{
{{- range $column, $options := $model.Columns}}
	{{- if not $options.IsCustom}}
		"{{$column}}": {
			sqlName:  "{{$options.SQLName $column}}",
			typeName: "{{$options.FilterType}}",
			{{- if $options.IsArray}}
				isArray: true,
			{{- end}}
		},
	{{- end}}
{{- end}}
}

{{- range $i, $method := $model.Methods}}
{{- if $model.IsStandardMethod $method}}
	{{- if IsGet $method}}
	func (a *Repo) {{ToAppMethodName $method}}{{$modelName}}({{if not $model.BoundToIsolatedEntity}}{{if IsMyMethod $method}}profileID{{else}}id{{end}} {{if $model.IDIsUUID}}string{{else}}int64{{end}}{{end}}{{if not $model.Shared}}{{if not $model.BoundToIsolatedEntity}}, {{end}}isolatedEntityID string{{end}}) (*app.{{$modelName}}, error) { 
		{{- if IsMyMethod $method}}
			id, err := a.getMy{{$modelName}}ID({{if not $model.BoundToIsolatedEntity}}profileID{{end}}{{if not $model.Shared}}{{if not $model.BoundToIsolatedEntity}}, {{end}}isolatedEntityID{{end}})
			if err != nil {
				return nil, err
			}
		{{- end}}
		{{- if IsAdjustGet $method}}
			var m {{$modelName}}
			if err := a.db.NamedGet(&m, sql{{ToAppMethodName $method}}{{$modelName}},  argGet{{$modelName}}{
				ID: newNull{{if $model.IDIsUUID}}UUID{{else}}Int64ID{{end}}(id),
				{{- if not $model.Shared}}
					IsolatedEntityID: isolatedEntityID,
				{{- end}} 
			}); err != nil {
				if err == sql.ErrNoRows {
					return nil, app.ErrNotFound
				} 
				return nil, err
			}
			{{- range $column, $options := $model.Columns}}
				{{- if and (ContainsStr (index $model.MethodsProps $i).AdjustGetJSONColumns $column) (or (and $options.IsArray (not $options.IsStruct)) $options.IsCustom)}}
					if err := json.Unmarshal(m.{{$options.TitleName}}JSON, &m.{{$options.TitleName}}); err != nil {
						return nil, err
					}
				{{- end}}
			{{- end}}
			{{- if $model.HaveLazyLoading}}
				if err := m.LazyLoading({{if not $model.Shared}}isolatedEntityID, {{end}}a); err != nil {
					return nil, err
				}
			{{- end}}
			return app{{$modelName}}(m), nil
		{{- else}}
			return a.get{{$modelName}}(id{{if not $model.Shared}}, isolatedEntityID{{end}})
		{{- end}}
	}
	{{- end}}
	{{- if IsAdd $method}}
	func (a *Repo) {{ToAppMethodName $method}}{{$modelName}}(profileID string, {{if not $model.Shared}}isolatedEntityID string, {{end}}m *app.{{$modelName}}) (*app.{{$modelName}}, error) {
		{{- if IsMyMethod $method}}
			_, err := a.getMy{{$modelName}}ID({{if not $model.BoundToIsolatedEntity}}profileID{{end}}{{if not $model.Shared}}{{if not $model.BoundToIsolatedEntity}}, {{end}}isolatedEntityID{{end}})
			if err == nil {
				return nil, app.ErrDuplicateID
			}
			if err != nil && err != app.ErrNotFound {
				return nil, err
			}
		{{- end}}
		id, err := a.add{{$modelName}}(profileID, {{if not $model.Shared}}isolatedEntityID, {{end}}m)
		if err != nil {
			return nil, err
		}
		{{- if IsMyMethod $method}}
			err = a.bindTo{{if $model.BoundToIsolatedEntity}}IsolatedEntity{{else}}Profile{{end}}{{$modelName}}(id{{if not $model.BoundToIsolatedEntity}}, profileID{{end}}{{if not $model.Shared}}, isolatedEntityID{{end}})
			if err != nil {
				return nil, err
			}
		{{- end}}
		return a.get{{$modelName}}(id{{if not $model.Shared}}, isolatedEntityID{{end}})
	}
	{{- end}}
	{{- if IsDelete $method}}
	func (a *Repo) {{ToAppMethodName $method}}{{$modelName}}({{if not (IsMyMethod $method)}}id {{if $model.IDIsUUID}}string{{else}}int64{{end}}, {{end}}profileID string{{if not $model.Shared}}, isolatedEntityID string{{end}}) error {
		{{- if IsMyMethod $method}}
			id, err := a.getMy{{$modelName}}ID({{if not $model.BoundToIsolatedEntity}}profileID{{end}}{{if not $model.Shared}}{{if not $model.BoundToIsolatedEntity}}, {{end}}isolatedEntityID{{end}})
			if err != nil {
				return err
			}
		{{- end}}
		t := time.Now()
		res, err := a.db.NamedExec(sqlDelete{{$modelName}}, argDelete{{$modelName}}{
			ID: id,
			DeletedAt: &t,
			DeletedBy: profileID,
			{{- if not $model.Shared}}
				IsolatedEntityID: isolatedEntityID,
			{{- end}}
		})
		if err != nil {
			return err
		}
		if count, _ := res.RowsAffected(); count == 0 {
			return app.ErrNotFound
		}
		
		return nil
	}
	{{- end}}
	{{- if IsEdit $method}}
	func (a *Repo) {{ToAppMethodName $method}}{{$modelName}}({{if not (IsMyMethod $method)}}id {{if $model.IDIsUUID}}string{{else}}int64{{end}}, {{end}}{{if or (and (IsMyMethod $method) (not $model.BoundToIsolatedEntity)) $model.HaveModifiedBy}}profileID string, {{end}}{{if not $model.Shared}}isolatedEntityID string, {{end}}m *app.{{$modelName}}) {{if $model.ReturnWhenEdit}}(*app.{{$modelName}}, error){{else}}error{{end}}  {
		{{- if IsMyMethod $method}}
			id, err := a.getMy{{$modelName}}ID({{if not $model.BoundToIsolatedEntity}}profileID{{end}}{{if not $model.Shared}}{{if not $model.BoundToIsolatedEntity}}, {{end}}isolatedEntityID{{end}})
			if err != nil{{if eq $method "editOrAddMy"}} && err != app.ErrNotFound{{end}} {
				return {{if $model.ReturnWhenEdit}}nil, {{end}}err
			}
		{{- end}}
		{{- if eq $method "editOrAddMy"}}
			if err == app.ErrNotFound {
				{{if $model.ReturnWhenEdit}}id{{else}}_{{end}}, err := a.add{{$modelName}}(profileID, {{if not $model.Shared}}isolatedEntityID, {{end}}m)
				if err != nil {
					return {{if $model.ReturnWhenEdit}}nil, {{end}}err
				}
				return {{if $model.ReturnWhenEdit}}a.get{{$modelName}}(id{{if not $model.Shared}}, isolatedEntityID{{end}}){{else}}nil{{end}}
			}
		{{- end}}
		{{- if IsAdjustEdit $method}}
			{{- range $column, $options := $model.Columns}}
				{{- if and (ContainsStr (index $model.MethodsProps $i).EditableFields $column) (IsAdjustEdit $method)}}
					{{- if and $options.IsStruct (not $options.IsArray)}}
						var {{$column}}ID interface{}
						if m.{{$options.TitleName}} != nil {
							{{$column}}ID = m.{{$options.TitleName}}.ID
						}
					{{- end}}
					{{- if or (and $options.IsArray (not $options.IsStruct)) $options.IsCustom}}
						{{$column}}JSON, _ := json.Marshal(m.{{$options.TitleName}})
					{{- end}}
				{{- end}}
			{{- end}}
			{{- if $model.HaveModifiedAt}}
				t := time.Now()
				m.ModifiedAt = &t
			{{- end}}
			{{- if $model.HaveModifiedBy}}
				m.ModifiedBy = profileID
			{{- end}}

			res, err := a.db.NamedExec(sql{{ToAppMethodName $method}}{{$modelName}}, arg{{ToAppMethodName $method}}{{$modelName}}{
				ID: id,
				{{- range $_, $column := (SortColumns $model.Columns)}}
					{{- $options := (index $model.Columns $column)}}
					{{- if ContainsStr (index $model.MethodsProps $i).EditableFields $column}}
						{{- if $options.IsStruct}}
							{{- if not $options.IsArray}}
								{{$options.TitleName}}ID: {{$column}}ID,
							{{- end}}
						{{- else}}
							{{- if $options.IsCustom}}
								{{$options.TitleName}}JSON: {{$column}}JSON,
							{{- else}}
								{{- if not $options.IsArray}}
									{{$options.TitleName}}: m.{{$options.TitleName}},
								{{- else}}
									{{$options.TitleName}}JSON: {{$column}}JSON,
								{{- end}}
							{{- end}}
						{{- end}}
					{{- end}}
				{{- end}}
				{{- if not $model.Shared}}
					IsolatedEntityID: isolatedEntityID,
				{{- end}}
			})
			if err != nil {
				return {{if $model.ReturnWhenEdit}}nil, {{end}}err
			}

			if count, _ := res.RowsAffected(); count == 0 {
				return {{if $model.ReturnWhenEdit}}nil, {{end}}app.ErrNotFound
			}
		{{- else}}
			if err := a.edit{{$modelName}}(id, {{if $model.HaveModifiedBy}}profileID, {{end}}{{if not $model.Shared}}isolatedEntityID, {{end}}m); err != nil {
				return {{if $model.ReturnWhenEdit}}nil, {{end}}err
			}
		{{- end}}
		

		return {{if $model.ReturnWhenEdit}}a.get{{$modelName}}(id{{if not $model.Shared}}, isolatedEntityID{{end}}){{else}}nil{{end}}
	}
	{{- end}}
	{{- if IsList $method}}
	func (a *Repo) {{ToAppMethodName $method}}{{$modelName}}({{if not $model.Shared}}isolatedEntityID string, {{end}}params *app.ListParams) ([]*app.{{$modelName}}, {{if $model.DetailedPagination}} int,{{end}}[]string, error) { 
		ms := []{{$modelName}}{}
		warnings := []string{}

		var orderQuery string 
		{{- if $haveNestedSorts}}
			var nestedSort bool
		{{- end}}
		switch params.SortBy {
			{{- if (IsAdjustList $method)}}
				{{- range $_, $key := (AvailableSortKeys $model.Columns (AvailableKeys (index $model.MethodsProps $i)))}}
					{{- if Contains $key "."}}
						case "{{$key}}":
							nestedSort = true
					{{- else}}
						case "{{$key}}":
							orderQuery = "ORDER BY {{$key}}"
					{{- end}}
				{{- end}}
			{{- else}}
				{{- range $_, $column := (SortColumns $model.Columns)}}
					{{- $options := (index $model.Columns $column)}}
					{{- if and $options.SortOn (not $options.IsStruct) }}
						case "{{$column}}":
							orderQuery = "ORDER BY {{NameSQL $column}}"
					{{- end}}
				{{- end}}
				{{- if $haveNestedSorts}}
					{{- range $_, $column := (SortColumns $model.Columns)}}
						{{- $options := (index $model.Columns $column)}}
						{{- range $j, $sort := $options.SortBy}}
						case "{{$column}}.{{$sort}}":
							nestedSort = true
						{{- end}}
					{{- end}}
				{{- end}}
			{{- end}}
			case "":
				{{- range $column, $options := $model.Columns}}
					{{- if $options.SortDefault }}
						orderQuery = "ORDER BY {{NameSQL $column}}"
						{{- if and $options.SortOrderDefault (or ((not (IsAdjustList $method))) (and (IsAdjustList $method) (ContainsStr (AvailableSortKeys $model.Columns (AvailableKeys (index $model.MethodsProps $i))) $column)))}}
							if params.OrderBy == "" {
								params.OrderBy = "{{$options.SortOrderDefault}}"
							}
						{{- end }}
					{{- end }}
				{{- end }}
			default:
				warnings = append(warnings, fmt.Sprintf("Sorting by '%s' is not avaliable or '%s' is not a valid sort key", params.SortBy, params.SortBy))
		}

		if orderQuery != "" {
			switch params.OrderBy {
			case "ASC", "":
				orderQuery += " ASC"
			case "DESC":
				orderQuery += " DESC"
			}
		}

		bf := newBuilderFilter(params.FilterGroups, {{$modelName}}Props)
		{{- if (IsAdjustList $method)}}
			warnings = append(warnings, bf.validateAvailableFilters(map[string]bool{
				{{- range $_, $key := (AvailableKeys (index $model.MethodsProps $i))}}
					"{{$key}}": true,
				{{- end}}
			})...)
		{{- end}}

		sqlFilters, namedVars, warningsFromPrepared := bf.preparedSQLFilters()
		warnings = append(warnings, warningsFromPrepared...)

		{{if not $model.Shared}}
			namedVars["isolated_entity_id"] = isolatedEntityID
		{{end}}

		var offset, limit string
		{{- if $model.DetailedPagination}}
			var count int
		{{- end}}
		var err error
		{{if and $model.HaveLazyLoading (or (not (IsAdjustList $method)) (and (IsAdjustList $method) ((index $model.MethodsProps $i).NeedLazyLoading)))}}
			nestedFilterGroups := bf.nestedFilterGroups()
			
			externalPagination := false
			if len(nestedFilterGroups) != 0 {{if $haveNestedSorts}}|| nestedSort{{end}} {
				externalPagination = true
			}
			if !externalPagination {
				{{- if $model.DetailedPagination}}
					err = a.db.NamedGet(&count, sqlList{{$modelName}}Count+sqlFilters, namedVars)
					if err != nil {
						return nil, -1, nil, err
					}
				{{- end}}
				offset = " OFFSET :offset"
				namedVars["offset"] = params.Offset
				if params.Limit != 0 {
					limit = " LIMIT :limit"
					namedVars["limit"] = params.Limit
				}
			}
		{{else}}
			{{- if $model.DetailedPagination}}
				err = a.db.NamedGet(&count, sqlList{{$modelName}}Count+sqlFilters, namedVars)
				if err != nil {
					return nil, -1, nil, err
				}
			{{- end}}
			offset = " OFFSET :offset"
			namedVars["offset"] = params.Offset
			limit = " LIMIT :limit"
			namedVars["limit"] = params.Limit
		{{end}}
		
		err = a.db.NamedSelect(&ms, sql{{if IsAdjustList $method}}{{ToAppMethodName $method}}{{else}}List{{end}}{{$modelName}}+sqlFilters+orderQuery+offset+limit, namedVars)
		if err != nil {
			return nil,{{if $model.DetailedPagination}} -1,{{end}} nil, err
		}

		{{- if or (and (not (IsAdjustList $method)) $model.HaveJSON) (and (IsAdjustList $method) (index $model.MethodsProps $i).HaveJSON)}}
			for i := range ms { 
			{{- range $column, $options := $model.Columns}}
				{{- if or (and (or (and $options.IsArray (not $options.IsStruct)) $options.IsCustom) (not (IsAdjustList $method))) (and (IsAdjustList $method) (index (index $model.MethodsProps $i).JSONColumns $column))}}
					if err := json.Unmarshal(ms[i].{{$options.TitleName}}JSON, &ms[i].{{$options.TitleName}}); err != nil {
						return nil,{{if $model.DetailedPagination}} -1,{{end}} nil, err
					}
				{{- end}}
			{{- end}}
			}
		{{- end}}
		
		result := {{if $model.HaveLazyLoading}}[]{{$modelName}}{}{{else}}ms{{end}}
		{{- if $model.HaveLazyLoading}}
			{{- if (IsAdjustList $method)}}
				{{- if or ((index $model.MethodsProps $i).NeedLazyLoading) ((index $model.MethodsProps $i).HaveJSON)}}
					for i := range ms {
						if err := ms[i].LazyLoading{{ToAppMethodName $method}}({{if not $model.Shared}}isolatedEntityID, {{end}}a); err != nil {
							return nil,{{if $model.DetailedPagination}} -1,{{end}} nil, err
						}

						ok := true 
						for j, filterGroup := range nestedFilterGroups {
							for _, filter := range filterGroup.Filters {
								var validFilter error
								{{- if $model.HaveLazyLoading}}
									ok, validFilter = ms[i].NestedFilter(filterGroup.Key, filter)
								{{- else}}
									ok, validFilter = ms[i].Filter(filterGroup.Key, filter)
								{{- end}}
								if validFilter != nil {
									warnings = append(warnings, fmt.Sprintf("Filter key: '%s'. Error: %s", filterGroup.Key, validFilter.Error()))
									nestedFilterGroups = append(nestedFilterGroups[:j], nestedFilterGroups[j+1:]...)
									j--
								}
								if (!ok && filterGroup.LogicFilter) || (ok && !filterGroup.LogicFilter) {
									break
								}
							}
						}
						if ok {
							result = append(result, ms[i])
						}
					}
				{{- else}}
					result = ms
				{{- end}}
			{{- else}}
				for i := range ms {
					if err := ms[i].LazyLoading({{if not $model.Shared}}isolatedEntityID, {{end}}a); err != nil {
						return nil,{{if $model.DetailedPagination}} -1,{{end}} nil, err
					}

					ok := true 
					for j, filterGroup := range nestedFilterGroups {
						for _, filter := range filterGroup.Filters {
							var validFilter error
							{{- if $model.HaveLazyLoading}}
								ok, validFilter = ms[i].NestedFilter(filterGroup.Key, filter)
							{{- else}}
								ok, validFilter = ms[i].Filter(filterGroup.Key, filter)
							{{- end}}
							if validFilter != nil {
								warnings = append(warnings, fmt.Sprintf("Filter key: '%s'. Error: %s", filterGroup.Key, validFilter.Error()))
								nestedFilterGroups = append(nestedFilterGroups[:j], nestedFilterGroups[j+1:]...)
								j--
							}
							if (!ok && filterGroup.LogicFilter) || (ok && !filterGroup.LogicFilter) {
								break
							}
						}
					}
					if ok {
						result = append(result, ms[i])
					}
				}
			{{- end}}
		{{- end}}
		{{- if $haveNestedSorts}}
			if nestedSort {
				var orderByASC bool
				switch params.OrderBy {
				case "ASC", "":
					orderByASC = true
				case "DESC":
					orderByASC = false
				}
				switch params.SortBy {
			{{- range $_, $column := (SortColumns $model.Columns)}}
				{{- $options := (index $model.Columns $column)}}
				{{- range $j, $sort := $options.SortBy}}
					{{- if or (not (IsAdjustList $method)) (and (IsAdjustList $method) (ContainsStr (AvailableSortKeys $model.Columns (AvailableKeys (index $model.MethodsProps $i))) (printf "%s.%s" $column $sort)))}}
						case "{{$column}}.{{$sort}}":
							if orderByASC {
								sort.Slice({{if $model.HaveLazyLoading}}result{{else}}result{{end}}, func(i, j int) bool { return {{if $model.HaveLazyLoading}}result{{else}}result{{end}}[i]{{index $options.NestedSorts $j}} < {{if $model.HaveLazyLoading}}result{{else}}result{{end}}[j]{{index $options.NestedSorts $j}} })
							} else {
								sort.Slice({{if $model.HaveLazyLoading}}result{{else}}result{{end}}, func(i, j int) bool { return {{if $model.HaveLazyLoading}}result{{else}}result{{end}}[i]{{index $options.NestedSorts $j}} >= {{if $model.HaveLazyLoading}}result{{else}}result{{end}}[j]{{index $options.NestedSorts $j}} })
							}
					{{- end}}
				{{- end}}
			{{- end}}
				}
			}
		{{- end}}

		{{if and $model.HaveLazyLoading (or (not (IsAdjustList $method)) (and (IsAdjustList $method) ((index $model.MethodsProps $i).NeedLazyLoading)))}}
			if externalPagination {
				{{- if $model.DetailedPagination}}
					count = len(result)
				{{- end}}
				start, end := pagination(int(params.Offset), int(params.Limit), len(result))
				result = result[start:end]
			}
		{{end}}

		return app{{$modelName}}s(result),{{if $model.DetailedPagination}} count,{{end}} warnings, nil
	}
	{{- end}}

	{{- if and (IsAdjustList $method) ((index $model.MethodsProps $i).NeedLazyLoading)}}
		{{- range $j, $nestedObj := (index $model.MethodsProps $i).NestedObjs}}
		{{- if $nestedObj.IsFirstForLazyLoading}}
			func (m *{{if $nestedObj.Path}}{{$nestedObj.ParentStruct}}{{else}}{{$modelName}}{{end}})LazyLoading{{ToAppMethodName $method}}{{$nestedObj.Path}}({{if $nestedObj.Path}}{{if not  (index $.Models $nestedObj.ParentStruct).Shared}} isolatedEntityID string, {{end}}{{else}}{{if not $model.Shared}}isolatedEntityID string, {{end}}{{end}}a *Repo) (err error) { 
		{{- end}} 
			{{- $model2 := (index $.Models $nestedObj.Type)}}
			{{- if  $nestedObj.IsArray}}
				{{- $sliceName := (print "slice" $nestedObj.Name)}}
				{{$sliceName}} := []{{if $nestedObj.Path}}{{$nestedObj.ParentStruct}}{{else}}{{$modelName}}{{end}}{{$nestedObj.Type}}{}
				if err = a.db.NamedSelect(&{{$sliceName}}, sqlGet{{$nestedObj.Name}}IDsFor{{if $nestedObj.Path}}{{$nestedObj.ParentStruct}}{{else}}{{$modelName}}{{end}}LazyLoading, argGet{{$modelName}}{
					ID: newNull{{if $model.IDIsUUID}}UUID{{else}}Int64ID{{end}}(m.ID{{if $model.IDIsUUID}}.String(){{end}}),
					{{- if not $model.Shared}}
						IsolatedEntityID: isolatedEntityID,
					{{- end}}
				}); err != nil {
					return
				}
				for _, cd := range {{$sliceName}} {
					var elem {{$nestedObj.Type}}
					if err = a.db.NamedGet(&elem, sqlGet{{$nestedObj.Name}}For{{ToAppMethodName $method}}, argGet{{$nestedObj.Type}}{
						ID: newNull{{if $model2.IDIsUUID}}UUID{{else}}Int64ID{{end}}(cd.{{$nestedObj.Type}}ID{{if $model2.IDIsUUID}}.String(){{end}}),
						{{- if not $model2.Shared}}
							IsolatedEntityID: isolatedEntityID,
						{{- end}}
					}); err != nil {
						return
					}
					{{- range $column2, $options2 := $model2.Columns}}
						{{- if  (index $nestedObj.JSONColumns $column2)}}
							if err != sql.ErrNoRows {
								if err = json.Unmarshal(elem.{{$options2.TitleName}}JSON, &elem.{{$options2.TitleName}}); err != nil {
									return
								}
							}
						{{- end}}
					{{- end}}
					{{- if $nestedObj.NeedLazyLoading}}
						if err == nil {
							if err = elem.LazyLoading{{ToAppMethodName $method}}{{$nestedObj.Path}}{{$nestedObj.Name}}({{if not $model2.Shared}}isolatedEntityID, {{end}}a); err != nil {
								return
							}
						}
					{{- end}}
					m.{{$nestedObj.Name}} = append(m.{{$nestedObj.Name}}, elem)
				}
			{{- else}}
				if err = a.db.NamedGet(&m.{{$nestedObj.Name}}, sqlGet{{$nestedObj.Name}}For{{ToAppMethodName $method}}, argGet{{$nestedObj.Type}}{
						ID: m.{{$nestedObj.Name}}ID,
						{{- if not $model2.Shared}}
							IsolatedEntityID: isolatedEntityID,
						{{- end}}
				}); err != nil && err != sql.ErrNoRows {
					return
				}
				{{- range $column2, $options2 := $model2.Columns}}
					{{- if  (index $nestedObj.JSONColumns $column2)}}
						if err != sql.ErrNoRows {
							if err = json.Unmarshal(m.{{$nestedObj.Name}}.{{$options2.TitleName}}JSON, &m.{{$nestedObj.Name}}.{{$options2.TitleName}}); err != nil {
								return
							}
						}
					{{- end}}
				{{- end}}
				{{- if $nestedObj.NeedLazyLoading}}
				if err == nil {
					if err = m.{{$nestedObj.Name}}.LazyLoading{{ToAppMethodName $method}}{{$nestedObj.Name}}({{if not $model2.Shared}}isolatedEntityID, {{end}}a); err != nil {
						return
					}
				}
				{{- end}}
			{{- end}}
		{{- if $nestedObj.IsLastForLazyLoading}}
				return nil
			}
		{{- end}}
		{{- end}}
	{{- end}}
{{end}}
{{- end}}

{{- if $model.HaveLazyLoading}}
func (m *{{$modelName}}) LazyLoading({{if not $model.Shared}}isolatedEntityID string, {{end}}a *Repo) (err error) { 
{{- range $modelName2, $model2 := $.Models}}
	{{- range $column, $options := $model.Columns}}
		{{- if eq $modelName2 $options.BusinessType}}
			{{- if and $options.IsArray $options.IsStruct}}
				slice{{$options.TitleName}} := []{{$modelName}}{{$options.BusinessType}}{}
				if err = a.db.NamedSelect(&slice{{$options.TitleName}}, sqlGet{{Title $column}}IDsFor{{$modelName}}LazyLoading, argGet{{$modelName}}{
					ID: newNull{{if $model.IDIsUUID}}UUID{{else}}Int64ID{{end}}(m.ID{{if $model.IDIsUUID}}.String(){{end}}),
					{{- if not $model.Shared}}
						IsolatedEntityID: isolatedEntityID,
					{{- end}}
				}); err != nil {
					return
				}
				for _, cd := range slice{{$options.TitleName}} {
					var {{$column}} {{$options.BusinessType}}
					if err = a.db.NamedGet(&{{$column}}, sqlGet{{Title $column}}For{{$modelName}}LazyLoading, argGet{{$modelName2}}{
						ID: newNull{{if $model2.IDIsUUID}}UUID{{else}}Int64ID{{end}}(cd.{{$options.BusinessType}}ID{{if $model2.IDIsUUID}}.String(){{end}}),
						{{- if not $model2.Shared}}
							IsolatedEntityID: isolatedEntityID,
						{{- end}}
					}); err != nil {
						return
					}
					{{- range $column2, $options2 := $model2.Columns}}
						{{- if  or (and $options2.IsArray (not $options2.IsStruct)) $options2.IsCustom}}
							if err = json.Unmarshal({{$column}}.{{$options2.TitleName}}JSON, &{{$column}}.{{$options2.TitleName}}); err != nil {
								return
							}
						{{- end}}
					{{- end}}
					{{- if $model2.HaveLazyLoading}}
						if err == nil {
							if err = {{$column}}.LazyLoading({{if not $model2.Shared}}isolatedEntityID, {{end}}a); err != nil {
								return
							}
						}
					{{- end}}
					m.{{$options.TitleName}} = append(m.{{$options.TitleName}}, {{$column}})
				}
			{{- else}}
				if err = a.db.NamedGet(&m.{{$options.TitleName}}, sqlGet{{Title $column}}For{{$modelName}}LazyLoading,  argGet{{$modelName2}}{
					ID: m.{{$options.TitleName}}ID,
					{{- if not $model2.Shared}}
						IsolatedEntityID: isolatedEntityID,
					{{- end}} 
				}); err != nil && err != sql.ErrNoRows {
					return
				}
				{{- range $column2, $options2 := $model2.Columns}}
					{{- if  or (and $options2.IsArray (not $options2.IsStruct)) $options2.IsCustom}}
						if err != sql.ErrNoRows {
							if err = json.Unmarshal(m.{{$options.TitleName}}.{{$options2.TitleName}}JSON, &m.{{$options.TitleName}}.{{$options2.TitleName}}); err != nil {
								return
							}
						}
					{{- end}}
				{{- end}}
				{{- if $model2.HaveLazyLoading}}
					if err == nil {
						if err = m.{{$options.TitleName}}.LazyLoading({{if not $model2.Shared}}isolatedEntityID, {{end}}a); err != nil {
							return
						}
					}
				{{- end}}
			{{- end}}
		{{- end}}
	{{- end}}
{{- end}}
	return nil
}
{{- end}}

{{- range $column, $options := $model.Columns}}
{{- if  and $options.IsArray $options.IsStruct}}
	func (a *Repo) Add{{Title $column}}{{$modelName}}(id {{if $model.IDIsUUID}}string{{else}}int64{{end}}, {{if $model.HaveModifiedBy}}profileID string, {{end}}{{if not $model.Shared}}isolatedEntityID string, {{end}}itemsID []{{if (index $.Models $options.BusinessType).IDIsUUID}}string{{else}}int64{{end}}, items []*app.{{$options.BusinessType}}) error {
		for _, item := range items {
			{{- $model2 := (index $.Models $options.BusinessType)}}
			id, err := a.add{{$options.BusinessType}}({{if $model2.IDIsUUID}}uuid.New().String(), {{end}}{{if not $model2.Shared}}isolatedEntityID, {{end}}item)
			if err != nil {
				return err
			}
			itemsID = append(itemsID, id)
		}
		for _, itemID := range itemsID {
			if _, err := a.db.NamedExec(sqlAddTo{{Title $column}}In{{$modelName}}, arg{{Title $column}}In{{$modelName}}{
				{{$modelName}}ID: id,
				{{$options.TitleName}}ID: itemID,
				{{- if not $model.Shared}}
					IsolatedEntityID: isolatedEntityID,
				{{- end}}
			}); err != nil {
				if strings.Contains(err.Error(), "violates foreign key constraint") {
					switch {
					case strings.Contains(err.Error(), "{{NameSQL $modelName}}_id_fkey"):
						return app.ErrNotFound
					case strings.Contains(err.Error(), "{{NameSQL $column}}_id_fkey"):
						return app.ErrNotFoundArrayItem
					}
				}
				return err
			}
		}
	{{- if or $model.HaveModifiedAt $model.HaveModifiedBy}}
		{{- if $model.HaveModifiedAt}}
			t := time.Now()
		{{- end}}
		if _, err := a.db.NamedExec(sqlSetModifiedParams{{$modelName}}, argSetModifiedParams{{$modelName}}{
			ID: id,
			{{- if $model.HaveModifiedAt}}
				ModifiedAt: &t,
			{{- end}}
			{{- if $model.HaveModifiedBy}}
				ModifiedBy: profileID,
			{{- end}}
			{{- if not $model.Shared}}
				IsolatedEntityID: isolatedEntityID,
			{{- end}}
		}); err != nil {
			return err
		}
	{{- end}}
		return nil
	}

	func (a *Repo) Delete{{Title $column}}{{$modelName}}(id {{if $model.IDIsUUID}}string{{else}}int64{{end}}, {{if $model.HaveModifiedBy}}profileID string, {{end}}{{if not $model.Shared}}isolatedEntityID string, {{end}}items []{{if (index $.Models $options.BusinessType).IDIsUUID}}string{{else}}int64{{end}}) error {
		for _, item := range items {
			res, err := a.db.NamedExec(sqlDeleteFrom{{Title $column}}In{{$modelName}}, arg{{Title $column}}In{{$modelName}}{
				{{$modelName}}ID: id,
				{{$options.TitleName}}ID: item,
				{{- if not $model.Shared}}
					IsolatedEntityID: isolatedEntityID,
				{{- end}}
			})
			if err != nil {
				return err
			}
			if count, _ := res.RowsAffected(); count == 0 {
				return app.ErrNotFound
			}
		}
	{{- if or $model.HaveModifiedAt $model.HaveModifiedBy}}
		{{- if $model.HaveModifiedAt}}
			t := time.Now()
		{{- end}}
		if _, err := a.db.NamedExec(sqlSetModifiedParams{{$modelName}}, argSetModifiedParams{{$modelName}}{
			ID: id,
			{{- if $model.HaveModifiedAt}}
				ModifiedAt: &t,
			{{- end}}
			{{- if $model.HaveModifiedBy}}
				ModifiedBy: profileID,
			{{- end}}
			{{- if not $model.Shared}}
				IsolatedEntityID: isolatedEntityID,
			{{- end}}
		}); err != nil {
			return err
		}
	{{- end}}
		return nil
	}
{{- end}}
{{- end}}

func (a *Repo) get{{$modelName}}(id {{if $model.IDIsUUID}}string{{else}}int64{{end}}{{if not $model.Shared}}, isolatedEntityID string{{end}}) (*app.{{$modelName}}, error) { 
	var m {{$modelName}}
	if err := a.db.NamedGet(&m, sqlGet{{$modelName}}, argGet{{$modelName}}{
		ID: newNull{{if $model.IDIsUUID}}UUID{{else}}Int64ID{{end}}(id),
		{{- if not $model.Shared}}
			IsolatedEntityID: isolatedEntityID,
		{{- end}} 
	}); err != nil {
		if err == sql.ErrNoRows {
			return nil, app.ErrNotFound
		} 
		return nil, err
	}
	{{- range $column, $options := $model.Columns}}
		{{- if  or (and $options.IsArray (not $options.IsStruct)) $options.IsCustom}}
			if err := json.Unmarshal(m.{{$options.TitleName}}JSON, &m.{{$options.TitleName}}); err != nil {
				return nil, err
			}
		{{- end}}
	{{- end}}
	{{- if $model.HaveLazyLoading}}
		if err := m.LazyLoading({{if not $model.Shared}}isolatedEntityID, {{end}}a); err != nil {
			return nil, err
		}
	{{- end}}
	return app{{$modelName}}(m), nil
}

func (a *Repo) add{{$modelName}}(profileID string, {{if not $model.Shared}}isolatedEntityID string, {{end}}m *app.{{$modelName}}) ({{if $model.IDIsUUID}}string{{else}}int64{{end}}, error) {
	{{- if $model.IDIsUUID}}
		{{$modelName}}ID := uuid.New().String()
	{{- else}}
		var {{$modelName}}ID int64
	{{- end}}
	{{- if $model.HaveCreatedAt}}
		t := time.Now()
		m.CreatedAt = &t
	{{- end}}
	{{- if $model.HaveCreatedBy}}
		m.CreatedBy = profileID
	{{- end}}
	{{- range $column, $options := $model.Columns}}
		{{- if and $options.IsStruct (not $options.IsArray)}}
			var {{$column}}ID interface{}
			if m.{{$options.TitleName}} != nil {
				{{$column}}ID = m.{{$options.TitleName}}.ID
			}
		{{- end}}
		{{- if  or (and $options.IsArray (not $options.IsStruct)) $options.IsCustom}}
			{{$column}}JSON, _ := json.Marshal(m.{{$options.TitleName}})
		{{- end}}
	{{- end}}
	if err := a.db.NamedGet(&{{$modelName}}ID, sqlAdd{{$modelName}}, argAdd{{$modelName}}{
		{{- if $model.IDIsUUID}}
			ID: {{$modelName}}ID,
		{{- end}}
		{{- range $_, $column := (SortColumns $model.Columns)}}
			{{- $options := (index $model.Columns $column)}}
			{{- if $options.IsStruct}}
				{{- if not $options.IsArray}}
					{{$options.TitleName}}ID: {{$column}}ID,
				{{- end}}
			{{- else}}
				{{- if $options.IsCustom}}
					{{$options.TitleName}}JSON: {{$column}}JSON,
				{{- else}}
					{{- if not $options.IsArray}}
						{{- if and (ne $options.TitleName "ID") (ne $options.TitleName "ModifiedBy") (ne $options.TitleName "ModifiedAt")}}
							{{$options.TitleName}}: m.{{$options.TitleName}},
						{{- end}} 
					{{- else}}
						{{$options.TitleName}}JSON: {{$column}}JSON,
					{{- end}}
				{{- end}}
			{{- end}}
		{{- end}}
		{{- if not $model.HaveCreatedBy}}
			CreatedBy: profileID,
		{{- end}}
		{{- if not $model.Shared}}
			IsolatedEntityID: isolatedEntityID,
		{{- end}}
	}); err != nil {
		if strings.Contains(err.Error(), "duplicate key value violates unique constraint") {
			return {{if $model.IDIsUUID}}""{{else}}0{{end}}, app.ErrDuplicateID
		}
		return {{if $model.IDIsUUID}}""{{else}}0{{end}}, err
	}
	{{- range $modelName2, $model2 := $.Models}}
		{{- range $column, $options := $model.Columns}}
			{{- if eq $modelName2 $options.BusinessType}}
				{{- if and $options.IsArray $options.IsStruct}}
					for _, m := range m.{{$options.TitleName}} {
						if _, err := a.db.NamedExec(sqlAddTo{{Title $column}}In{{$modelName}}, arg{{Title $column}}In{{$modelName}}{
							{{$modelName}}ID: {{$modelName}}ID,
							{{$options.TitleName}}ID: m.ID,
							{{- if not $model.Shared}}
								IsolatedEntityID: isolatedEntityID,
							{{- end}}
						}); err != nil {
							return {{if $model.IDIsUUID}}""{{else}}0{{end}}, err
						}
					}
				{{- end}}
			{{- end}}
		{{- end}}
	{{- end}}
	return {{$modelName}}ID{{if $model.IDIsUUID}}{{end}}, nil
}

func (a *Repo) getMy{{$modelName}}ID({{if not $model.BoundToIsolatedEntity}}profileID{{end}}{{if not $model.Shared}}{{if not $model.BoundToIsolatedEntity}}, {{end}}isolatedEntityID{{end}} string) (id string, err error) {
	if err = a.db.NamedGet(&id, sqlGetMy{{$modelName}}ID, argGetMy{{$modelName}}ID{
		{{- if not $model.BoundToIsolatedEntity}}
			CreatedBy: profileID,
		{{- end}}
		{{- if not $model.Shared}}
			IsolatedEntityID: isolatedEntityID,
		{{- end}}
	}); err != nil {
		if err == sql.ErrNoRows {
			return "", app.ErrNotFound
		}
		return
	}
	return
}

func (a *Repo) bindTo{{if $model.BoundToIsolatedEntity}}IsolatedEntity{{else}}Profile{{end}}{{$modelName}}(id{{if not $model.BoundToIsolatedEntity}}, profileID{{end}}{{if not $model.Shared}}, isolatedEntityID{{end}} string) error {
	res, err := a.db.NamedExec(sqlBind{{$modelName}}To{{if $model.BoundToIsolatedEntity}}IsolatedEntity{{else}}Profile{{end}}, argBind{{$modelName}}To{{if $model.BoundToIsolatedEntity}}IsolatedEntity{{else}}Profile{{end}}{
		ID: id,
		{{- if not $model.BoundToIsolatedEntity}}
			CreatedBy: profileID,
		{{- end}}
		{{- if not $model.Shared}}
			IsolatedEntityID: isolatedEntityID,
		{{- end}}
	})
	if err != nil {
		return err
	}

	if count, _ := res.RowsAffected(); count == 0 {
		return app.ErrNotFound
	}
	return nil
}

func (a *Repo) edit{{$modelName}}(id {{if $model.IDIsUUID}}string{{else}}int64{{end}}, {{if $model.HaveModifiedBy}}profileID string, {{end}}{{if not $model.Shared}}isolatedEntityID string, {{end}}m *app.{{$modelName}}) error  {
	{{- range $column, $options := $model.Columns}}
		{{- if and $options.IsStruct (not $options.IsArray)}}
			var {{$column}}ID interface{}
			if m.{{$options.TitleName}} != nil {
				{{$column}}ID = m.{{$options.TitleName}}.ID
			}
		{{- end}}
		{{- if or (and $options.IsArray (not $options.IsStruct)) $options.IsCustom}}
			{{$column}}JSON, _ := json.Marshal(m.{{$options.TitleName}})
		{{- end}}
	{{- end}}
	{{- if $model.HaveModifiedAt}}
		t := time.Now()
		m.ModifiedAt = &t
	{{- end}}
	{{- if $model.HaveModifiedBy}}
		m.ModifiedBy = profileID
	{{- end}}

	res, err := a.db.NamedExec(sqlEdit{{$modelName}}, argEdit{{$modelName}}{
		{{- range $_, $column := (SortColumns $model.Columns)}}
			{{- $options := (index $model.Columns $column)}}
			{{- if $options.IsStruct}}
				{{- if not $options.IsArray}}
					{{$options.TitleName}}ID: {{$column}}ID,
				{{- end}}
			{{- else}}
				{{- if $options.IsCustom}}
					{{$options.TitleName}}JSON: {{$column}}JSON,
				{{- else}}
					{{- if not $options.IsArray}}
						{{- if eq $options.TitleName "ID"}}
							ID: id,
						{{- else}}
							{{$options.TitleName}}: m.{{$options.TitleName}},
						{{- end}} 
					{{- else}}
						{{$options.TitleName}}JSON: {{$column}}JSON,
					{{- end}}
				{{- end}}
			{{- end}}
		{{- end}}
		{{- if not $model.Shared}}
			IsolatedEntityID: isolatedEntityID,
		{{- end}}
	})
	if err != nil {
		return err
	}

	if count, _ := res.RowsAffected(); count == 0 {
			return app.ErrNotFound
	}

	return nil
}

{{- range $functionName, $function := $.Functions}}
func (a *Repo) {{$functionName}}{{$modelName}}({{$function.InStrFull}}) ({{$function.OutStrType}}, error){
	{{- range $name, $type := $function.Out}}
		var {{$name}} {{$type}}
	{{- end}}
	/* Example:
	if err := a.db.Get(&key, `SELECT key FROM components WHERE title=$1`, serviceName); err != nil {
		return "", err
	}*/

	return {{$function.OutStr}}, nil
}
{{- end}}

{{- if $model.HaveLazyLoading}}
func (m *{{$modelName}}) NestedFilter(key string, filter *app.Filter) (ok bool, err error) {
	if strings.Contains(key, ".") {
		splitedFilter := strings.SplitN(key, ".", 2)
		key = splitedFilter[1]
		switch splitedFilter[0] {
		{{- range $_, $column := (SortColumns $model.Columns)}}
			{{- $options := (index $model.Columns $column)}}
			{{- if $options.IsStruct}}
			case "{{$column}}":
				{{- if $options.IsArray}}
					for _, elem := range m.{{$options.TitleName}} {
						ok, err = elem.{{if (index $models $options.BusinessType).HaveLazyLoading}}Nested{{end}}Filter(key, filter)
						if ok || err != nil {
							break
						}
					}
				{{- else}}
					ok, err = m.{{$options.TitleName}}.{{if (index $models $options.BusinessType).HaveLazyLoading}}Nested{{end}}Filter(key, filter)
				{{- end}}
			{{- end}}
		{{- end}}
		default:
			ok, err = true, errNotExistFilterKey
		}
	} else {
		ok, err = m.Filter(key, filter)
	}
	return
}
{{- end}}

func (m *{{$modelName}}) Filter(key string, filter *app.Filter) (ok bool, err error) {
	columnType := {{$modelName}}Props[key].typeName
	if err = validateOperator(filter.Operator, columnType); err != nil {
		return true, err
	}
	if err = vaidateIgnoreCase(filter.IgnoreCase, columnType); err != nil {
		return true, err
	}
	if err := validateValue(filter.Value, columnType); err != nil {
		return true, err
	}
	switch key {
	{{- range $_, $column := (SortColumns $model.Columns)}}
		{{- $options := (index $model.Columns $column)}}
		{{- if and (not $options.IsStruct) (not (and $options.IsStruct $options.IsArray)) (not $options.IsCustom)}}
			{{- $filterType := $options.FilterType}}
			case "{{$column}}":
				{{- if eq $filterType "uuid"}}
					{{- if $options.IsArray}}
						for _, elem := range m.{{$options.TitleName}} {
						ok = compareUUID(filter.Operator, elem, filter.Value)
							if ok {
								break
							}
						}
					{{- else}}
						ok = compareUUID(filter.Operator, m.{{$options.TitleName}}, filter.Value)
					{{- end}}
				{{- end}}
				{{- if eq $filterType "string"}}
					{{- if $options.IsArray}}
						for _, elem := range m.{{$options.TitleName}} {
						ok = compareString(filter.Operator, filter.IgnoreCase, elem, filter.Value)
							if ok {
								break
							}
						}
					{{- else}}
						ok = compareString(filter.Operator, filter.IgnoreCase, m.{{$options.TitleName}}.String, filter.Value)
					{{- end}}
				{{- end}}
				{{- if eq $filterType "date-time"}}
					{{- if $options.IsArray}}
						for _, elem := range m.{{$options.TitleName}} {
						ok = compareTime(filter.Operator, *elem, filter.Value)
							if ok {
								break
							}
						}
					{{- else}}
						ok = compareTime(filter.Operator, *m.{{$options.TitleName}}, filter.Value)
					{{- end}}
				{{- end}}
				{{- if eq $filterType "date"}}
					{{- if $options.IsArray}}
						for _, elem := range m.{{$options.TitleName}} {
						ok = compareDate(filter.Operator, *elem, filter.Value)
							if ok {
								break
							}
						}
					{{- else}}
						ok = compareDate(filter.Operator, *m.{{$options.TitleName}}, filter.Value)
					{{- end}}
				{{- end}}
				{{- if eq $filterType "int32"}}
					{{- if $options.IsArray}}
						for _, elem := range m.{{$options.TitleName}} {
						ok = compareInt64(filter.Operator, int64(elem), filter.Value)
							if ok {
								break
							}
						}
					{{- else}}
						ok = compareInt64(filter.Operator, int64(m.{{$options.TitleName}}.Int32), filter.Value)
					{{- end}}
				{{- end}}
				{{- if eq $filterType "int64"}}
					{{- if $options.IsArray}}
						for _, elem := range m.{{$options.TitleName}} {
						ok = compareInt64(filter.Operator, elem, filter.Value)
							if ok {
								break
							}
						}
					{{- else}}
						ok = compareInt64(filter.Operator, m.{{$options.TitleName}}.Int64, filter.Value)
					{{- end}}
				{{- end}}
				{{- if eq $filterType "float"}}
					{{- if $options.IsArray}}
						for _, elem := range m.{{$options.TitleName}} {
						ok = compareFloat64(filter.Operator, elem, filter.Value)
							if ok {
								break
							}
						}
					{{- else}}
						ok = compareFloat64(filter.Operator, m.{{$options.TitleName}}.Float64, filter.Value)
					{{- end}}
				{{- end}}
				{{- if eq $filterType "decimal"}}
					{{- if $options.IsArray}}
						for _, elem := range m.{{$options.TitleName}} {
						ok = compareDecimal(filter.Operator,  elem, filter.Value)
							if ok {
								break
							}
						}
					{{- else}}
						ok = compareDecimal(filter.Operator,  m.{{$options.TitleName}}.Decimal, filter.Value)
					{{- end}}
				{{- end}}
				{{- if eq $filterType "bool"}}
					{{- if $options.IsArray}}
						for _, elem := range m.{{$options.TitleName}} {
						ok = compareBool(filter.Operator,  elem, filter.Value)
							if ok {
								break
							}
						}
					{{- else}}
						ok = compareBool(filter.Operator,  m.{{$options.TitleName}}.Bool, filter.Value)
					{{- end}}
				{{- end}}
		{{- end}}
	{{- end}}
	default:
		ok, err = true, errNotExistFilterKey
	}
	return
}

func app{{$modelName}}(m {{$modelName}}) *app.{{$modelName}} {
	if {{if $model.IDIsUUID}}m.ID.String() == "00000000-0000-0000-0000-000000000000"{{else}}m.ID == 0{{end}} {
		return nil
	}
	return &app.{{$modelName}}{
		{{- range $_, $name := (SortColumns $model.Columns)}}
			{{- $options := (index $model.Columns $name)}}
			{{$options.TitleName}}: {{ConvertDalToAppColumn $options}},
		{{- end}}
	}
}

func app{{$modelName}}s(ms []{{$modelName}}) []*app.{{$modelName}} {
	ams := []*app.{{$modelName}}{}
	for _, m := range ms {
		ams = append(ams, app{{$modelName}}(m))
	}

	return ams
}

{{- $modelName := .CurModel}}
{{- $model := (index $.Models $modelName)}}
{{- $models := .Models}}
{{- $haveNestedSorts := false}}
{{- range $_, $opts := $model.Columns}}
	{{- if $opts.NestedSorts}}
		{{- $haveNestedSorts = true}}
	{{- end}}
{{- end}}
// Code generated by mtgroup-generator.
package dal

import (
	"database/sql"
	"strings"
{{- if and $model.HaveListMethod $haveNestedSorts}}
	"sort"
{{- end}}
{{- if or $model.HaveCreatedAt $model.HaveModifiedAt (ContainsStr $model.Methods "Delete") (ContainsStr $model.Methods "DeleteMy")}}
	"time"
{{- end}}
{{- if HaveListWithWarn $model}}
	"fmt"
{{- end}}
{{- if or $model.HaveJSON (HaveColumnWithModelThatIsStructAndIsArray $model.Columns $.Models false true)}}
	"encoding/json"
{{- end}}

	"{{.Module}}/internal/app"
{{- if $model.NeedTypes}}
	"{{.Module}}/internal/types"
{{- end}}

{{- if or $model.IDIsUUID (ContainsStr $model.Methods "AddMy")}}
	"github.com/google/uuid"
{{- else}}
	{{- $inputed := false}}
	{{- range $name, $options := $model.Columns}}
		{{- $model2 := (index $.Models $options.GoType)}}
		{{- if and $model2.IDIsUUID (not $inputed) (not $options.IsArray)}}
	"github.com/google/uuid"
			{{- $inputed = true}}
		{{- end}}
	{{- end}}
{{- end}}
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

type {{$modelName}} struct { 
{{- range $i, $psqlParams := $model.Psql}}
	{{- if $psqlParams.IsStruct}}
		{{- if not $psqlParams.IsArray}}
			{{$psqlParams.Name}}ID {{if eq  $psqlParams.TypeSQL "uuid"}}sql.NullString{{else}}sql.NullInt64{{end}} `db:"{{$psqlParams.SQLName}}"`
		{{- end}}
		{{$psqlParams.Name}} {{if $psqlParams.IsArray}}[]{{end}}{{$psqlParams.Type}}
	{{- else}}
		{{- if $psqlParams.IsCustom}}
			{{$psqlParams.Name}}JSON []byte `db:"{{$psqlParams.SQLName}}"`
			{{$psqlParams.Name}} {{if $psqlParams.IsArray}}[]{{end}}app.{{$psqlParams.Type}} 
		{{- else}}
			{{- if not $psqlParams.IsArray}}
				{{$psqlParams.Name}} {{if eq  $psqlParams.TypeSQL "uuid"}}uuid.UUID{{else}}{{DalType $psqlParams.Type}}{{end}} `db:"{{$psqlParams.SQLName}}"` 
			{{- else}}
				{{$psqlParams.Name}}JSON []byte `db:"{{$psqlParams.SQLName}}"`
				{{$psqlParams.Name}} []{{$psqlParams.Type}} 
			{{- end}}
		{{- end}}
	{{- end}}
{{- end}}
}

{{- range $i, $method := $model.Methods}}
{{- if not (IsCustomMethod $method)}}
	{{- if IsGet $method}}
	func (a *Repo) {{$method}}{{$modelName}}({{if not $model.BoundToIsolatedEntity}}{{if IsMyMethod $method}}profileID{{else}}id{{end}} {{if $model.IDIsUUID}}string{{else}}int64{{end}}{{end}}{{if not $model.Shared}}{{if not $model.BoundToIsolatedEntity}}, {{end}}isolatedEntityID string{{end}}) (*app.{{$modelName}}, error) { 
		{{- if IsMyMethod $method}}
			id, err := a.getMy{{$modelName}}ID({{if not $model.BoundToIsolatedEntity}}profileID{{end}}{{if not $model.Shared}}{{if not $model.BoundToIsolatedEntity}}, {{end}}isolatedEntityID{{end}})
			if err != nil {
				return nil, err
			}
		{{- end}}
		{{- if IsAdjustGet $method}}
			var m {{$modelName}}
			if err := a.db.NamedGet(&m, sql{{$method}}{{$modelName}},  argGet{{$modelName}}{
				ID: newNull{{if $model.IDIsUUID}}UUID{{else}}Int64ID{{end}}(id),
				{{- if not $model.Shared}}
					IsolatedEntityID: isolatedEntityID,
				{{- end}} 
			}); err != nil {
				if err == sql.ErrNoRows {
					return nil, app.ErrNotFound
				} 
				return nil, err
			}
			{{- range $column, $options := $model.Columns}}
				{{- if and (ContainsStr (index $model.MethodsProps $i).AdjustGetJSONColumns $column) (or (and $options.IsArray (not $options.IsStruct)) $options.IsCustom)}}
					if err := json.Unmarshal(m.{{$options.TitleName}}JSON, &m.{{$options.TitleName}}); err != nil {
						return nil, err
					}
				{{- end}}
			{{- end}}
			{{- if $model.HaveLazyLoading}}
				if err := m.LazyLoading({{if not $model.Shared}}isolatedEntityID, {{end}}a); err != nil {
					return nil, err
				}
			{{- end}}
			return app{{$modelName}}(m), nil
		{{- else}}
			return a.get{{$modelName}}(id{{if not $model.Shared}}, isolatedEntityID{{end}})
		{{- end}}
	}
	{{- end}}
	{{- if IsAdd $method}}
	func (a *Repo) {{$method}}{{$modelName}}(profileID string, {{if not $model.Shared}}isolatedEntityID string, {{end}}m *app.{{$modelName}}) (*app.{{$modelName}}, error) {
		{{- if IsMyMethod $method}}
			_, err := a.getMy{{$modelName}}ID({{if not $model.BoundToIsolatedEntity}}profileID{{end}}{{if not $model.Shared}}{{if not $model.BoundToIsolatedEntity}}, {{end}}isolatedEntityID{{end}})
			if err == nil {
				return nil, app.ErrDuplicateID
			}
			if err != nil && err != app.ErrNotFound {
				return nil, err
			}
		{{- end}}
		id, err := a.add{{$modelName}}(profileID, {{if not $model.Shared}}isolatedEntityID, {{end}}m)
		if err != nil {
			return nil, err
		}
		{{- if IsMyMethod $method}}
			err = a.bindTo{{if $model.BoundToIsolatedEntity}}IsolatedEntity{{else}}Profile{{end}}{{$modelName}}(id{{if not $model.BoundToIsolatedEntity}}, profileID{{end}}{{if not $model.Shared}}, isolatedEntityID{{end}})
			if err != nil {
				return nil, err
			}
		{{- end}}
		return a.get{{$modelName}}(id{{if not $model.Shared}}, isolatedEntityID{{end}})
	}
	{{- end}}
	{{- if IsDelete $method}}
	func (a *Repo) {{$method}}{{$modelName}}({{if not (IsMyMethod $method)}}id {{if $model.IDIsUUID}}string{{else}}int64{{end}}, {{end}}profileID string{{if not $model.Shared}}, isolatedEntityID string{{end}}) error {
		{{- if IsMyMethod $method}}
			id, err := a.getMy{{$modelName}}ID({{if not $model.BoundToIsolatedEntity}}profileID{{end}}{{if not $model.Shared}}{{if not $model.BoundToIsolatedEntity}}, {{end}}isolatedEntityID{{end}})
			if err != nil {
				return err
			}
		{{- end}}
		res, err := a.db.NamedExec(sqlDelete{{$modelName}}, argDelete{{$modelName}}{
			ID: id,
			DeletedAt: time.Now(),
			DeletedBy: profileID,
			{{- if not $model.Shared}}
				IsolatedEntityID: isolatedEntityID,
			{{- end}}
		})
		if err != nil {
			return err
		}
		if count, _ := res.RowsAffected(); count == 0 {
			return app.ErrNotFound
		}
		
		return nil
	}
	{{- end}}
	{{- if IsEdit $method}}
	func (a *Repo) {{$method}}{{$modelName}}({{if not (IsMyMethod $method)}}id {{if $model.IDIsUUID}}string{{else}}int64{{end}}, {{end}}{{if or (and (IsMyMethod $method) (not $model.BoundToIsolatedEntity)) $model.HaveModifiedBy}}profileID string, {{end}}{{if not $model.Shared}}isolatedEntityID string, {{end}}m *app.{{$modelName}}) {{if $model.ReturnWhenEdit}}(*app.{{$modelName}}, error){{else}}error{{end}}  {
		{{- if IsMyMethod $method}}
			id, err := a.getMy{{$modelName}}ID({{if not $model.BoundToIsolatedEntity}}profileID{{end}}{{if not $model.Shared}}{{if not $model.BoundToIsolatedEntity}}, {{end}}isolatedEntityID{{end}})
			if err != nil{{if eq $method "EditOrAddMy"}} && err != app.ErrNotFound{{end}} {
				return {{if $model.ReturnWhenEdit}}nil, {{end}}err
			}
		{{- end}}
		{{- if eq $method "EditOrAddMy"}}
			if err == app.ErrNotFound {
				{{if $model.ReturnWhenEdit}}id{{else}}_{{end}}, err := a.add{{$modelName}}(profileID, {{if not $model.Shared}}isolatedEntityID, {{end}}m)
				if err != nil {
					return {{if $model.ReturnWhenEdit}}nil, {{end}}err
				}
				return {{if $model.ReturnWhenEdit}}a.get{{$modelName}}(id{{if not $model.Shared}}, isolatedEntityID{{end}}){{else}}nil{{end}}
			}
		{{- end}}
		{{- if IsAdjustEdit $method}}
			{{- range $column, $options := $model.Columns}}
				{{- if and (ContainsStr (index $model.MethodsProps $i).EditableFields $column) (IsAdjustEdit $method)}}
					{{- if and $options.IsStruct (not $options.IsArray)}}
						var {{$column}}ID interface{}
						if m.{{$options.TitleName}} != nil {
							{{$column}}ID = m.{{$options.TitleName}}.ID
						}
					{{- end}}
					{{- if or (and $options.IsArray (not $options.IsStruct)) $options.IsCustom}}
						{{$column}}JSON, _ := json.Marshal(m.{{$options.TitleName}})
					{{- end}}
				{{- end}}
			{{- end}}
			{{- if $model.HaveModifiedAt}}
				m.ModifiedAt = time.Now()
			{{- end}}
			{{- if $model.HaveModifiedBy}}
				m.ModifiedBy = profileID
			{{- end}}

			res, err := a.db.NamedExec(sql{{$method}}{{$modelName}}, arg{{$method}}{{$modelName}}{
				ID: id,
				{{- range $column, $options := $model.Columns}}
					{{- if ContainsStr (index $model.MethodsProps $i).EditableFields $column}}
						{{- if $options.IsStruct}}
							{{- if not $options.IsArray}}
								{{$options.TitleName}}ID: {{$column}}ID,
							{{- end}}
						{{- else}}
							{{- if $options.IsCustom}}
								{{$options.TitleName}}JSON: {{$column}}JSON,
							{{- else}}
								{{- if not $options.IsArray}}
									{{$options.TitleName}}: m.{{$options.TitleName}},
								{{- else}}
									{{$options.TitleName}}JSON: {{$column}}JSON,
								{{- end}}
							{{- end}}
						{{- end}}
					{{- end}}
				{{- end}}
				{{- if not $model.Shared}}
					IsolatedEntityID: isolatedEntityID,
				{{- end}}
			})
			if err != nil {
				return {{if $model.ReturnWhenEdit}}nil, {{end}}err
			}

			if count, _ := res.RowsAffected(); count == 0 {
				return {{if $model.ReturnWhenEdit}}nil, {{end}}app.ErrNotFound
			}
		{{- else}}
			if err := a.edit{{$modelName}}(id, {{if $model.HaveModifiedBy}}profileID, {{end}}{{if not $model.Shared}}isolatedEntityID, {{end}}m); err != nil {
				return {{if $model.ReturnWhenEdit}}nil, {{end}}err
			}
		{{- end}}
		

		return {{if $model.ReturnWhenEdit}}a.get{{$modelName}}(id{{if not $model.Shared}}, isolatedEntityID{{end}}){{else}}nil{{end}}
	}
	{{- end}}
	{{- if IsList $method}}
	func (a *Repo) {{$method}}{{$modelName}}({{if not $model.Shared}}isolatedEntityID string, {{end}}offset, limit int64, filters []*app.Filter, logicFilter bool, sortBy, orderBy string) ([]*app.{{$modelName}}, {{if $model.DetailedPagination}} int,{{end}}[]string, error) { 
		ms := []{{$modelName}}{}
		warnings := []string{}

		var orderQuery string 
		{{- if $haveNestedSorts}}
			var nestedSort bool
		{{- end}}
		switch sortBy {
			{{- range $column, $options := $model.Columns }}
				{{- if and $options.SortOn (not $options.IsStruct) }}
					case "{{$column}}":
						orderQuery = "ORDER BY {{NameSQL $column}}"
				{{- end}}
			{{- end}}
			default:
				{{- $completeIfStmt := false }}
				{{- range $column, $options := $model.Columns}}
					{{- if $options.SortDefault }}
						{{/* {{- if $haveNestedSorts }} */}}
							{{- $completeIfStmt = true }}
							if sortBy == "" { 
						{{/* {{- end}} */}}
								orderQuery = "ORDER BY {{NameSQL $column}}"
						{{- if $options.SortOrderDefault}}
								if orderBy == "" {
									orderBy = "{{$options.SortOrderDefault}}"
								}
						{{- end }}
					{{- end }}
				{{- end }}
				{{- if and $haveNestedSorts $completeIfStmt}}
							} else {
								nestedSort = true
				{{- end}}
				{{- if and $haveNestedSorts (not $completeIfStmt)}}
								nestedSort = true
				{{- end}}
				{{- if $completeIfStmt}}
							}
				{{- end}}
		}

		if orderQuery != "" {
			switch orderBy {
			case "ASC", "":
				orderQuery += " ASC"
			case "DESC":
				orderQuery += " DESC"
			}
		}

		mapQuery := map[string]interface{}{ 
			{{- if IsAdjustList $method}}
				{{- range $_, $column := (index $model.MethodsProps $i).FilteredFields}}
					{{- if not (index (index $model.MethodsProps $i).JSONColumns $column)}}
						"{{$column}}": nil,
						"not_{{$column}}": nil,
					{{- end}}
				{{- end}}
			{{- else}}
				{{- range $column, $options := $model.Columns}}
					{{- if and (not $options.IsArray) (not $options.IsCustom)}}
						"{{$column}}": nil,
						"not_{{$column}}": nil,
					{{- end}}
				{{- end}}
			{{- end}}
			{{- if not $model.Shared}}
				"isolated_entity_id": isolatedEntityID,
			{{- end}}
		}

		{{- if NeedCustomFilter $model $method}}
			customFilters := []*app.Filter{}
		{{- end}}

		{{- if or (index $model.MethodsProps $i).FilteredFields (not (IsAdjustList $method))}}
			if logicFilter {
				for _, filter := range filters {
					switch filter.Key { 
				{{- if IsAdjustList $method}}
					{{- range $_, $column := (index $model.MethodsProps $i).FilteredFields}}
						{{- if not (index (index $model.MethodsProps $i).JSONColumns $column)}}
						case "{{$column}}":
							if filter.Include {
								mapQuery["{{$column}}"] = {{if IsNotStrictFilter $model $column}}"%%" + {{end}}filter.Value{{if IsNotStrictFilter $model $column}} + "%%"{{end}}
							} else {
								mapQuery["not_{{$column}}"] = {{if IsNotStrictFilter $model $column}}"%%" + {{end}}filter.Value{{if IsNotStrictFilter $model $column}} + "%%"{{end}}
							}
						{{- end}}
					{{- end}}
				{{- else}}
					{{- range $column, $options := $model.Columns}}
						{{- if  and (not $options.IsArray) (not $options.IsCustom)}}
						case "{{$column}}":
							if filter.Include {
								mapQuery["{{$column}}"] = {{if IsNotStrictFilter $model $column}}"%%" + {{end}}filter.Value{{if IsNotStrictFilter $model $column}} + "%%"{{end}}
							} else {
								mapQuery["not_{{$column}}"] = {{if IsNotStrictFilter $model $column}}"%%" + {{end}}filter.Value{{if IsNotStrictFilter $model $column}} + "%%"{{end}}
							}
						{{- end}}
					{{- end}}
				{{- end}}
					default:
						customFilters = append(customFilters, filter)
					}
				}
			} else {
				for _, filter := range filters {
					customFilters = append(customFilters, filter)
				}
			}
		{{- end}}
		
		err := a.db.NamedSelect(&ms, sql{{if IsAdjustList $method}}{{$method}}{{else}}List{{end}}{{$modelName}} + orderQuery, mapQuery)
		if err != nil {
			return nil,{{if $model.DetailedPagination}} -1,{{end}} nil, err
		}

		{{- if or (and (not (IsAdjustList $method)) $model.HaveJSON) (and (IsAdjustList $method) (index $model.MethodsProps $i).HaveJSON)}}
			for i := range ms { 
			{{- range $column, $options := $model.Columns}}
				{{- if or (and (or (and $options.IsArray (not $options.IsStruct)) $options.IsCustom) (not (IsAdjustList $method))) (and (IsAdjustList $method) (index (index $model.MethodsProps $i).JSONColumns $column))}}
					if err := json.Unmarshal(ms[i].{{$options.TitleName}}JSON, &ms[i].{{$options.TitleName}}); err != nil {
						return nil,{{if $model.DetailedPagination}} -1,{{end}} nil, err
					}
				{{- end}}
			{{- end}}
			}
		{{- end}}
		
		result := []{{$modelName}}{}
		{{- if $model.HaveLazyLoading}}
			{{- if (IsAdjustList $method)}}
				{{- if or ((index $model.MethodsProps $i).NeedLazyLoading) ((index $model.MethodsProps $i).HaveJSON)}}
					for i := range ms {
					{{- if (index $model.MethodsProps $i).NeedLazyLoading}}
						if err := ms[i].LazyLoading{{$method}}({{if not $model.Shared}}isolatedEntityID, {{end}}a); err != nil {
							return nil,{{if $model.DetailedPagination}} -1,{{end}} nil, err
						}
					{{- end}}
						ok := true
						for j := 0; j < len(customFilters); j++ {
							var validFilter bool
							filterKey := customFilters[j].Key
						{{- if (index $model.MethodsProps $i).NeedLazyLoading}}
							if !logicFilter && !strings.Contains(customFilters[j].Key, ".") {
								ok, validFilter = ms[i].Filter(customFilters[j])
							} else {
								ok, validFilter = ms[i].NestedFilter(customFilters[j])
							}
						{{- else}}
							ok, validFilter = ms[i].Filter(customFilters[j])
						{{- end}}
							customFilters[j].Key = filterKey
							if !validFilter {
								warnings = append(warnings, fmt.Sprintf("filter key '%s' is not valid", customFilters[j].Key))
								customFilters = append(customFilters[:j], customFilters[j+1:]...)
								j--
							}
							if (!ok && logicFilter) || (ok && !logicFilter) {
								break
							}
						}
						if ok {
							result = append(result, ms[i])
						}
					}
				{{- else}}
					result = ms
				{{- end}}
			{{- else}}
				for i := range ms {
					if err := ms[i].LazyLoading({{if not $model.Shared}}isolatedEntityID, {{end}}a); err != nil {
						return nil,{{if $model.DetailedPagination}} -1,{{end}} nil, err
					}
					ok := true
					for j := 0; j < len(customFilters); j++ {
						var validFilter bool
						filterKey := customFilters[j].Key
					{{- if $model.HaveLazyLoading}}
						if !logicFilter && !strings.Contains(customFilters[j].Key, ".") {
							ok, validFilter = ms[i].Filter(customFilters[j])
						} else {
							ok, validFilter = ms[i].NestedFilter(customFilters[j])
						}
					{{- else}}
						ok, validFilter = ms[i].Filter(customFilters[j])
					{{- end}}
						customFilters[j].Key = filterKey
						if !validFilter {
							warnings = append(warnings, fmt.Sprintf("filter key '%s' is not valid", customFilters[j].Key))
							customFilters = append(customFilters[:j], customFilters[j+1:]...)
							j--
						}
						if (!ok && logicFilter) || (ok && !logicFilter) {
							break
						}
					}
					if ok {
						result = append(result, ms[i])
					}
				}
			{{- end}}
		{{- else}}
			for i := range ms {
				ok := true
				for j := 0; j < len(customFilters); j++ {
					var validFilter bool
					ok, validFilter = ms[i].Filter(customFilters[j])
					if !validFilter {
						warnings = append(warnings, fmt.Sprintf("filter key '%s' is not valid", customFilters[j].Key))
						customFilters = append(customFilters[:j], customFilters[j+1:]...)
						j--
					}
					if (!ok && logicFilter) || (ok && !logicFilter) {
						break
					}
				}
				if ok {
					result = append(result, ms[i])
				}
			}
		{{- end}}
		{{- if $haveNestedSorts}}
			if nestedSort {
				var orderByASC bool
				switch orderBy {
				case "ASC", "":
					orderByASC = true
				case "DESC":
					orderByASC = false
				}
				switch sortBy { 
			{{- range $column, $options := $model.Columns}}
				{{- range $j, $sort := $options.SortBy}}
				case "{{$column}}.{{$sort}}":
					if orderByASC {
						sort.Slice({{if $model.HaveLazyLoading}}result{{else}}ms{{end}}, func(i, j int) bool { return {{if $model.HaveLazyLoading}}result{{else}}ms{{end}}[i]{{index $options.NestedSorts $j}} < {{if $model.HaveLazyLoading}}result{{else}}ms{{end}}[j]{{index $options.NestedSorts $j}} })
					} else {
						sort.Slice({{if $model.HaveLazyLoading}}result{{else}}ms{{end}}, func(i, j int) bool { return {{if $model.HaveLazyLoading}}result{{else}}ms{{end}}[i]{{index $options.NestedSorts $j}} >= {{if $model.HaveLazyLoading}}result{{else}}ms{{end}}[j]{{index $options.NestedSorts $j}} })
					}
				{{- end}}
			{{- end}}
				default:
					warnings = append(warnings, fmt.Sprintf("sorting by '%s' is not avaliable or '%s' is not a valid sort key", sortBy, sortBy))
				}
			}
		{{- end}}

		start, end := pagination(int(offset), int(limit), len(result))

		return app{{$modelName}}s(result[start:end]),{{if $model.DetailedPagination}} len(result),{{end}} warnings, nil
	}
	{{- end}}

	{{- if and (IsAdjustList $method) ((index $model.MethodsProps $i).NeedLazyLoading)}}
		{{- range $j, $nestedObj := (index $model.MethodsProps $i).NestedObjs}}
		{{- if $nestedObj.IsFirstForLazyLoading}}
			func (m *{{if $nestedObj.Path}}{{$nestedObj.ParentStruct}}{{else}}{{$modelName}}{{end}})LazyLoading{{$method}}{{$nestedObj.Path}}({{if $nestedObj.Path}}{{if not  (index $.Models $nestedObj.ParentStruct).Shared}} isolatedEntityID string, {{end}}{{else}}{{if not $model.Shared}}isolatedEntityID string, {{end}}{{end}}a *Repo) (err error) { 
		{{- end}} 
			{{- $model2 := (index $.Models $nestedObj.Type)}}
			{{- if  $nestedObj.IsArray}}
				{{- $sliceName := (print "slice" $nestedObj.Name)}}
				{{$sliceName}} := []{{if $nestedObj.Path}}{{$nestedObj.ParentStruct}}{{else}}{{$modelName}}{{end}}{{$nestedObj.Type}}{}
				if err = a.db.Select(&{{$sliceName}}, sqlGet{{$nestedObj.Name}}IDsFor{{if $nestedObj.Path}}{{$nestedObj.ParentStruct}}{{else}}{{$modelName}}{{end}}LazyLoading, m.ID{{if not $model2.Shared}}, isolatedEntityID{{end}}); err != nil {
					return
				}
				for _, cd := range {{$sliceName}} {
					var elem {{$nestedObj.Type}}
					if err = a.db.Get(&elem, sqlGet{{$nestedObj.Name}}For{{$method}}, cd.{{$nestedObj.Type}}ID{{if not $model2.Shared}}, isolatedEntityID{{end}}); err != nil {
						return
					}
					{{- if $nestedObj.NeedLazyLoading}}
						if err == nil {
							if err = elem.LazyLoading{{$method}}{{$nestedObj.Path}}{{$nestedObj.Name}}({{if not $model2.Shared}}isolatedEntityID, {{end}}a); err != nil {
								return
							}
						}
					{{- end}}
					m.{{$nestedObj.Name}} = append(m.{{$nestedObj.Name}}, elem)
				}
			{{- else}}
				if err = a.db.Get(&m.{{$nestedObj.Name}}, sqlGet{{$nestedObj.Name}}For{{$method}}, m.{{$nestedObj.Name}}ID{{if not $model2.Shared}}, isolatedEntityID{{end}}); err != nil && err != sql.ErrNoRows {
					return
				}
				{{- if $nestedObj.NeedLazyLoading}}
				if err == nil {
					if err = m.{{$nestedObj.Name}}.LazyLoading{{$method}}{{$nestedObj.Name}}({{if not $model2.Shared}}isolatedEntityID, {{end}}a); err != nil {
						return
					}
				}
				{{- end}}
			{{- end}}
		{{- if $nestedObj.IsLastForLazyLoading}}
				return nil
			}
		{{- end}}
		{{- end}}
	{{- end}}
{{end}}
{{- end}}

{{- if $model.HaveLazyLoading}}
func (m *{{$modelName}}) LazyLoading({{if not $model.Shared}}isolatedEntityID string, {{end}}a *Repo) (err error) { 
{{- range $modelName2, $model2 := $.Models}}
	{{- range $column, $options := $model.Columns}}
		{{- if eq $modelName2 $options.GoType}}
			{{- if and $options.IsArray $options.IsStruct}}
				slice{{$options.TitleName}} := []{{$modelName}}{{$options.GoType}}{}
				if err = a.db.NamedSelect(&slice{{$options.TitleName}}, sqlGet{{Title $column}}IDsFor{{$modelName}}LazyLoading, argGet{{$modelName}}{
					ID: newNull{{if $model.IDIsUUID}}UUID{{else}}Int64ID{{end}}(m.ID{{if $model.IDIsUUID}}.String(){{end}}),
					{{- if not $model.Shared}}
						IsolatedEntityID: isolatedEntityID,
					{{- end}}
				}); err != nil {
					return
				}
				for _, cd := range slice{{$options.TitleName}} {
					var {{$column}} {{$options.GoType}}
					if err = a.db.NamedGet(&{{$column}}, sqlGet{{Title $column}}For{{$modelName}}LazyLoading, argGet{{$modelName2}}{
						ID: newNull{{if $model2.IDIsUUID}}UUID{{else}}Int64ID{{end}}(cd.{{$options.GoType}}ID{{if $model2.IDIsUUID}}.String(){{end}}),
						{{- if not $model2.Shared}}
							IsolatedEntityID: isolatedEntityID,
						{{- end}}
					}); err != nil {
						return
					}
					{{- range $column2, $options2 := $model2.Columns}}
						{{- if  or (and $options2.IsArray (not $options2.IsStruct)) $options2.IsCustom}}
							if err = json.Unmarshal({{$column}}.{{$options2.TitleName}}JSON, &{{$column}}.{{$options2.TitleName}}); err != nil {
								return
							}
						{{- end}}
					{{- end}}
					{{- if $model2.HaveLazyLoading}}
						if err == nil {
							if err = {{$column}}.LazyLoading({{if not $model2.Shared}}isolatedEntityID, {{end}}a); err != nil {
								return
							}
						}
					{{- end}}
					m.{{$options.TitleName}} = append(m.{{$options.TitleName}}, {{$column}})
				}
			{{- else}}
				if err = a.db.NamedGet(&m.{{$options.TitleName}}, sqlGet{{Title $column}}For{{$modelName}}LazyLoading,  argGet{{$modelName2}}{
					ID: m.{{$options.TitleName}}ID,
					{{- if not $model2.Shared}}
						IsolatedEntityID: isolatedEntityID,
					{{- end}} 
				}); err != nil && err != sql.ErrNoRows {
					return
				}
				{{- range $column2, $options2 := $model2.Columns}}
					{{- if  or (and $options2.IsArray (not $options2.IsStruct)) $options2.IsCustom}}
						if err != sql.ErrNoRows {
							if err = json.Unmarshal(m.{{$options.TitleName}}.{{$options2.TitleName}}JSON, &m.{{$options.TitleName}}.{{$options2.TitleName}}); err != nil {
								return
							}
						}
					{{- end}}
				{{- end}}
				{{- if $model2.HaveLazyLoading}}
					if err == nil {
						if err = m.{{$options.TitleName}}.LazyLoading({{if not $model2.Shared}}isolatedEntityID, {{end}}a); err != nil {
							return
						}
					}
				{{- end}}
			{{- end}}
		{{- end}}
	{{- end}}
{{- end}}
	return nil
}
{{- end}}

{{- range $column, $options := $model.Columns}}
{{- if  and $options.IsArray $options.IsStruct}}
	func (a *Repo) Add{{Title $column}}{{$modelName}}(id {{if $model.IDIsUUID}}string{{else}}int64{{end}}, {{if $model.HaveModifiedBy}}profileID string, {{end}}{{if not $model.Shared}}isolatedEntityID string, {{end}}itemsID []{{if (index $.Models $options.GoType).IDIsUUID}}string{{else}}int64{{end}}, items []*app.{{$options.GoType}}) error {
		for _, item := range items {
			{{- $model2 := (index $.Models $options.GoType)}}
			id, err := a.add{{$options.GoType}}({{if $model2.IDIsUUID}}uuid.New().String(), {{end}}{{if not $model2.Shared}}isolatedEntityID, {{end}}item)
			if err != nil {
				return err
			}
			itemsID = append(itemsID, id)
		}
		for _, itemID := range itemsID {
			if _, err := a.db.Exec(sqlAddTo{{Title $column}}In{{$modelName}}, id, itemID{{if not $model.Shared}}, isolatedEntityID{{end}}); err != nil {
				if strings.Contains(err.Error(), "violates foreign key constraint") {
					switch {
					case strings.Contains(err.Error(), "{{NameSQL $modelName}}_id_fkey"):
						return app.ErrNotFound
					case strings.Contains(err.Error(), "{{NameSQL $column}}_id_fkey"):
						return app.ErrNotFoundArrayItem
					}
				}
				return err
			}
		}
	{{- if or $model.HaveModifiedAt $model.HaveModifiedBy}}
		if _, err := a.db.Exec(sqlSetModifiedParams{{$modelName}}, id{{if not $model.Shared}}, isolatedEntityID{{end}}{{if $model.HaveModifiedAt}}, time.Now(){{end}}{{if $model.HaveModifiedBy}}, profileID{{end}}); err != nil {
			return {{if $model.ReturnWhenEdit}}nil, {{end}}err
		}
	{{- end}}
		return nil
	}

	func (a *Repo) Delete{{Title $column}}{{$modelName}}(id {{if $model.IDIsUUID}}string{{else}}int64{{end}}, {{if $model.HaveModifiedBy}}profileID string, {{end}}{{if not $model.Shared}}isolatedEntityID string, {{end}}items []{{if (index $.Models $options.GoType).IDIsUUID}}string{{else}}int64{{end}}) error {
		for _, item := range items {
			res, err := a.db.Exec(sqlDeleteFrom{{Title $column}}In{{$modelName}}, id, item{{if not $model.Shared}}, isolatedEntityID{{end}})
			if err != nil {
				return err
			}
			if count, _ := res.RowsAffected(); count == 0 {
				return app.ErrNotFound
			}
		}
	{{- if or $model.HaveModifiedAt $model.HaveModifiedBy}}
		if _, err := a.db.Exec(sqlSetModifiedParams{{$modelName}}, id{{if not $model.Shared}}, isolatedEntityID{{end}}{{if $model.HaveModifiedAt}}, time.Now(){{end}}{{if $model.HaveModifiedBy}}, profileID{{end}}); err != nil {
			return err
		}
	{{- end}}
		return nil
	}
{{- end}}
{{- end}}

func (a *Repo) {{$modelName}}AccessManager(am *app.AccessManager) error {
	if _, err := a.db.Exec(`INSERT INTO {{Pluralize (NameSQL $modelName)}}_access VALUES ($1, $2, $3, $4, $5, $6, $7)`, am.User, am.Group, am.Read, am.Write, am.Delete, am.Add, am.AccessManager); err != nil {
		return err
	}
	return nil
}

func (a *Repo) get{{$modelName}}(id {{if $model.IDIsUUID}}string{{else}}int64{{end}}{{if not $model.Shared}}, isolatedEntityID string{{end}}) (*app.{{$modelName}}, error) { 
	var m {{$modelName}}
	if err := a.db.NamedGet(&m, sqlGet{{$modelName}}, argGet{{$modelName}}{
		ID: newNull{{if $model.IDIsUUID}}UUID{{else}}Int64ID{{end}}(id),
		{{- if not $model.Shared}}
			IsolatedEntityID: isolatedEntityID,
		{{- end}} 
	}); err != nil {
		if err == sql.ErrNoRows {
			return nil, app.ErrNotFound
		} 
		return nil, err
	}
	{{- range $column, $options := $model.Columns}}
		{{- if  or (and $options.IsArray (not $options.IsStruct)) $options.IsCustom}}
			if err := json.Unmarshal(m.{{$options.TitleName}}JSON, &m.{{$options.TitleName}}); err != nil {
				return nil, err
			}
		{{- end}}
	{{- end}}
	{{- if $model.HaveLazyLoading}}
		if err := m.LazyLoading({{if not $model.Shared}}isolatedEntityID, {{end}}a); err != nil {
			return nil, err
		}
	{{- end}}
	return app{{$modelName}}(m), nil
}

func (a *Repo) add{{$modelName}}(profileID string, {{if not $model.Shared}}isolatedEntityID string, {{end}}m *app.{{$modelName}}) ({{if $model.IDIsUUID}}string{{else}}int64{{end}}, error) {
	{{- if $model.IDIsUUID}}
		{{$modelName}}ID := uuid.New().String()
	{{- else}}
		var {{$modelName}}ID int64
	{{- end}}
	{{- if $model.HaveCreatedAt}}
		m.CreatedAt = time.Now()
	{{- end}}
	{{- if $model.HaveCreatedBy}}
		m.CreatedBy = profileID
	{{- end}}
	{{- range $column, $options := $model.Columns}}
		{{- if and $options.IsStruct (not $options.IsArray)}}
			var {{$column}}ID interface{}
			if m.{{$options.TitleName}} != nil {
				{{$column}}ID = m.{{$options.TitleName}}.ID
			}
		{{- end}}
		{{- if  or (and $options.IsArray (not $options.IsStruct)) $options.IsCustom}}
			{{$column}}JSON, _ := json.Marshal(m.{{$options.TitleName}})
		{{- end}}
	{{- end}}
	if err := a.db.NamedGet(&{{$modelName}}ID, sqlAdd{{$modelName}}, argAdd{{$modelName}}{
		{{- if $model.IDIsUUID}}
			ID: {{$modelName}}ID,
		{{- end}}
		{{- range $column, $options := $model.Columns}}
			{{- if $options.IsStruct}}
				{{- if not $options.IsArray}}
					{{$options.TitleName}}ID: {{$column}}ID,
				{{- end}}
			{{- else}}
				{{- if $options.IsCustom}}
					{{$options.TitleName}}JSON: {{$column}}JSON,
				{{- else}}
					{{- if not $options.IsArray}}
						{{- if ne $options.TitleName "ID"}}
							{{$options.TitleName}}: m.{{$options.TitleName}},
						{{- end}} 
					{{- else}}
						{{$options.TitleName}}JSON: {{$column}}JSON,
					{{- end}}
				{{- end}}
			{{- end}}
		{{- end}}
		{{- if not $model.HaveCreatedBy}}
			CreatedBy: profileID,
		{{- end}}
		{{- if not $model.Shared}}
			IsolatedEntityID: isolatedEntityID,
		{{- end}}
	}); err != nil {
		if strings.Contains(err.Error(), "duplicate key value violates unique constraint") {
			return {{if $model.IDIsUUID}}""{{else}}0{{end}}, app.ErrDuplicateID
		}
		return {{if $model.IDIsUUID}}""{{else}}0{{end}}, err
	}
	{{- range $modelName2, $model2 := $.Models}}
		{{- range $column, $options := $model.Columns}}
			{{- if eq $modelName2 $options.GoType}}
				{{- if and $options.IsArray $options.IsStruct}}
					for _, m := range m.{{$options.TitleName}} {
						if _, err := a.db.NamedExec(sqlAddTo{{Title $column}}In{{$modelName}}, argAddTo{{Title $column}}In{{$modelName}}{
							{{$modelName}}ID: {{$modelName}}ID,
							{{$options.TitleName}}ID: m.ID,
							{{- if not $model.Shared}}
								IsolatedEntityID: isolatedEntityID,
							{{- end}}
						}); err != nil {
							return {{if $model.IDIsUUID}}""{{else}}0{{end}}, err
						}
					}
				{{- end}}
			{{- end}}
		{{- end}}
	{{- end}}
	return {{$modelName}}ID{{if $model.IDIsUUID}}{{end}}, nil
}

func (a *Repo) getMy{{$modelName}}ID({{if not $model.BoundToIsolatedEntity}}profileID{{end}}{{if not $model.Shared}}{{if not $model.BoundToIsolatedEntity}}, {{end}}isolatedEntityID{{end}} string) (id string, err error) {
	if err = a.db.NamedGet(&id, sqlGetMy{{$modelName}}ID, argGetMy{{$modelName}}ID{
		{{- if not $model.BoundToIsolatedEntity}}
			CreatedBy: profileID,
		{{- end}}
		{{- if not $model.Shared}}
			IsolatedEntityID: isolatedEntityID,
		{{- end}}
	}); err != nil {
		if err == sql.ErrNoRows {
			return "", app.ErrNotFound
		}
		return
	}
	return
}

func (a *Repo) bindTo{{if $model.BoundToIsolatedEntity}}IsolatedEntity{{else}}Profile{{end}}{{$modelName}}(id{{if not $model.BoundToIsolatedEntity}}, profileID{{end}}{{if not $model.Shared}}, isolatedEntityID{{end}} string) error {
	res, err := a.db.NamedExec(sqlBind{{$modelName}}To{{if $model.BoundToIsolatedEntity}}IsolatedEntity{{else}}Profile{{end}}, argBind{{$modelName}}To{{if $model.BoundToIsolatedEntity}}IsolatedEntity{{else}}Profile{{end}}{
		ID: id,
		{{- if not $model.BoundToIsolatedEntity}}
			CreatedBy: profileID,
		{{- end}}
		{{- if not $model.Shared}}
			IsolatedEntityID: isolatedEntityID,
		{{- end}}
	})
	if err != nil {
		return err
	}

	if count, _ := res.RowsAffected(); count == 0 {
		return app.ErrNotFound
	}
	return nil
}

func (a *Repo) edit{{$modelName}}(id {{if $model.IDIsUUID}}string{{else}}int64{{end}}, {{if $model.HaveModifiedBy}}profileID string, {{end}}{{if not $model.Shared}}isolatedEntityID string, {{end}}m *app.{{$modelName}}) error  {
	{{- range $column, $options := $model.Columns}}
		{{- if and $options.IsStruct (not $options.IsArray)}}
			var {{$column}}ID interface{}
			if m.{{$options.TitleName}} != nil {
				{{$column}}ID = m.{{$options.TitleName}}.ID
			}
		{{- end}}
		{{- if or (and $options.IsArray (not $options.IsStruct)) $options.IsCustom}}
			{{$column}}JSON, _ := json.Marshal(m.{{$options.TitleName}})
		{{- end}}
	{{- end}}
	{{- if $model.HaveModifiedAt}}
		m.ModifiedAt = time.Now()
	{{- end}}
	{{- if $model.HaveModifiedBy}}
		m.ModifiedBy = profileID
	{{- end}}

	res, err := a.db.NamedExec(sqlEdit{{$modelName}}, argEdit{{$modelName}}{
		{{- range $column, $options := $model.Columns}}
			{{- if $options.IsStruct}}
				{{- if not $options.IsArray}}
					{{$options.TitleName}}ID: {{$column}}ID,
				{{- end}}
			{{- else}}
				{{- if $options.IsCustom}}
					{{$options.TitleName}}JSON: {{$column}}JSON,
				{{- else}}
					{{- if not $options.IsArray}}
						{{- if eq $options.TitleName "ID"}}
							ID: id,
						{{- else}}
							{{$options.TitleName}}: m.{{$options.TitleName}},
						{{- end}} 
					{{- else}}
						{{$options.TitleName}}JSON: {{$column}}JSON,
					{{- end}}
				{{- end}}
			{{- end}}
		{{- end}}
		{{- if not $model.Shared}}
			IsolatedEntityID: isolatedEntityID,
		{{- end}}
	})
	if err != nil {
		return err
	}

	if count, _ := res.RowsAffected(); count == 0 {
			return app.ErrNotFound
	}

	return nil
}

{{- range $functionName, $function := $.Functions}}
func (a *Repo) {{$functionName}}{{$modelName}}({{$function.InStrFull}}) ({{$function.OutStrType}}, error){
	{{- range $name, $type := $function.Out}}
		var {{$name}} {{$type}}
	{{- end}}
	/* Example:
	if err := a.db.Get(&key, `SELECT key FROM components WHERE title=$1`, serviceName); err != nil {
		return "", err
	}*/

	return {{$function.OutStr}}, nil
}
{{- end}}

{{- if $model.HaveLazyLoading}}
func (m *{{$modelName}}) NestedFilter(filter *app.Filter) (ok, filterIsValid bool) {
	if strings.Contains(filter.Key, ".") {
		splitedFilter := strings.SplitN(filter.Key, ".", 2)
		filter.Key = splitedFilter[1]
		switch splitedFilter[0] {
		{{- range $column, $options := $model.Columns}}
			{{- if and $options.IsStruct (not $options.IsArray)}}
			case "{{$column}}":
				ok, filterIsValid = m.{{$options.TitleName}}.{{if (index $models $options.GoType).HaveLazyLoading}}Nested{{end}}Filter(filter)
			{{- end}}
		{{- end}}
		default:
			ok, filterIsValid = true, false
		}
	} else {
		ok, filterIsValid = m.Filter(filter)
	}
	return
}
{{- end}}

func (m *{{$modelName}}) Filter(filter *app.Filter) (ok, filterIsValid bool) {
	switch filter.Key {
	{{- range $column, $options := $model.Columns}}
		{{- if and (not $options.IsStruct) (not $options.IsCustom)}}
		case "{{$column}}":
			{{- if $options.IsArray}}
			for _, elem := range m.{{$options.TitleName}} {
			{{- end}}
				value := toString({{if $options.IsArray}}elem{{else}}m.{{$options.TitleName}}.{{if eq $options.GoType "types.Decimal"}}Decimal.String(){{else}}{{if (IsTimeFormat $options.Format)}}Time{{else}}{{Title $options.GoType}}{{if and (eq $options.TitleName "ID") $model.IDIsUUID}}(){{end}}{{end}}{{end}}{{end}})
				equal := {{if or (ne $options.Type "string") $options.StrictFilter}}value == filter.Value{{else}}contains(value, filter.Value){{end}}
				if (equal && filter.Include) || (!equal && !filter.Include) {
					ok, filterIsValid = true, true
				} else {
					ok, filterIsValid = false, true
				}
			{{- if $options.IsArray}}
			}
			{{- end}}
		{{- end}}
	{{- end}}
	default:
		ok, filterIsValid = true, false
	}
	return
}

func app{{$modelName}}(m {{$modelName}}) *app.{{$modelName}} {
	if {{if $model.IDIsUUID}}m.ID.String() == "00000000-0000-0000-0000-000000000000"{{else}}m.ID == 0{{end}} {
		return nil
	}
	return &app.{{$modelName}}{
		{{- range $name, $options := $model.Columns}}
			{{$options.TitleName}}: {{ConvertDalToAppColumn $options}},
		{{- end}}
	}
}

func app{{$modelName}}s(ms []{{$modelName}}) []*app.{{$modelName}} {
	ams := []*app.{{$modelName}}{}
	for _, m := range ms {
		ams = append(ams, app{{$modelName}}(m))
	}

	return ams
}

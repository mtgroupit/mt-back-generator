// Code generated by mtgroup-generator.  {{$modelName := .CurModel}} {{$model := (index $.Models $modelName)}}
package dal

import (
	{{if $model.HaveListMethod}}"strings"
	"strconv"{{end}}

	"{{.Name}}/internal/app"

	{{if $model.IDIsUUID}}"github.com/google/uuid"{{else}}{{$inputed := false}}{{range $name, $options := $model.Columns}}{{$model2 := (index $.Models $options.GoType)}}{{if and $model2.IDIsUUID (not $inputed) (not $options.IsArray)}}"github.com/google/uuid"{{$inputed = true}}{{end}}{{end}}{{end}}
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

type {{$modelName}} struct { {{range $i, $psqlParams := $model.Psql}}{{if $psqlParams.IsStruct}}
	{{if not $psqlParams.IsArray}}{{$psqlParams.Name}}ID {{if eq  $psqlParams.TypeSql "uuid"}}uuid.UUID{{else}}int64{{end}} `db:"{{$psqlParams.SqlName}}"`{{end}}
	{{$psqlParams.Name}} {{if $psqlParams.IsArray}}[]{{end}}{{$psqlParams.Type}}{{else}}
	{{$psqlParams.Name}} {{if eq  $psqlParams.TypeSql "uuid"}}uuid.UUID{{else}}{{$psqlParams.Type}}{{end}} `db:"{{$psqlParams.SqlName}}"` {{end}}{{end}}
}

{{range $i, $method := $model.Methods}}
{{if eq $method "Get"}}func (a *App) {{$method}}{{$modelName}}(id int64) (*app.{{$modelName}}, error) { 
	var m {{$modelName}}
	if err := a.db.Get(&m, `SELECT {{$model.SqlSelectStr}} FROM {{NameSQL $modelName}}s WHERE id=$1`, id); err != nil {
		return nil, err
	}{{if $model.HaveLazyLoading}}
	if err := m.LazyLoading(a); err != nil {
		return nil, err
	}{{end}}
	return app{{$modelName}}(m), nil
}{{end}}
{{if eq $method "Add"}}func (a *App) {{$method}}{{$modelName}}(m *app.{{$modelName}}) error {
	{{if $model.IDIsUUID}}{{$modelName}}ID := uuid.New(){{else}}var {{$modelName}}ID int64{{end}}
	if err := a.db.Get(&{{$modelName}}ID, `INSERT INTO {{NameSQL $modelName}}s{{$model.SqlAddStr}} RETURNING id`, {{$model.SqlExecParams}}{{if $model.IDIsUUID}}, {{$modelName}}ID{{end}}); err != nil {
		return err
	}{{range $modelName2, $model2 := $.Models}}{{range $column, $options := $model.Columns}}{{if eq $modelName2 $options.GoType}}{{if $options.IsArray}}
	for _, m := range m.{{$options.TitleName}} {
		if _, err := a.db.Exec(`INSERT INTO {{NameSQL $modelName}}_{{NameSQL $column}}({{$modelName}}_id, {{NameSQL $column}}_id) VALUES ($1, $2)`, {{$modelName}}ID, m.ID); err != nil {
			return err
		}
	}{{end}}{{end}}{{end}}{{end}}
	return nil
}{{end}}
{{if eq $method "Delete"}}func (a *App) {{$method}}{{$modelName}}(id int64) error { {{range $modelName2, $model2 := $.Models}}{{range $column, $options := $model.Columns}}{{if eq $modelName2 $options.GoType}}{{if $options.IsArray}}
	if _, err := a.db.Exec(`DELETE FROM {{NameSQL $modelName}}_{{NameSQL $column}} WHERE {{$modelName}}_id=$1`, id); err != nil {
		return err
	}{{end}}{{end}}{{end}}{{end}} {{range $_, $bind := $model.Binds}}{{if $bind.IsArray}}
	if _, err := a.db.Exec(`DELETE FROM {{NameSQL $bind.ModelName}}_{{NameSQL $bind.FieldName}} WHERE {{$bind.FieldName}}_id=$1`, id); err != nil {
		return err
	}{{else}}
	if _, err := a.db.Exec(`UPDATE {{NameSQL $bind.ModelName}}s SET {{$bind.FieldName}}_id=NULL WHERE {{$bind.FieldName}}_id=$1`, id); err != nil {
		return err
	}{{end}}{{end}}
	if _, err := a.db.Exec(`DELETE FROM {{NameSQL $modelName}}s WHERE id=$1`, id); err != nil {
		return err
	}
	return nil
}{{end}}
{{if eq $method "Edit"}}func (a *App) {{$method}}{{$modelName}}(id int64, m *app.{{$modelName}}) error  {
	if _, err := a.db.Exec(`UPDATE {{NameSQL $modelName}}s SET {{$model.SqlEditStr}} WHERE id=$1`, id, {{$model.SqlExecParams}}); err != nil {
		return err
	}{{range $modelName2, $model2 := $.Models}}{{range $column, $options := $model.Columns}}{{if eq $modelName2 $options.GoType}}{{if $options.IsArray}}
	if len(m.{{$options.TitleName}}) != 0 {
		if _, err := a.db.Exec(`DELETE FROM {{NameSQL $modelName}}_{{NameSQL $column}} WHERE {{$modelName}}_id=$1`, id); err != nil {
			return err
		}
		for _, {{$column}} := range m.{{$options.TitleName}} {
			if _, err := a.db.Exec(`INSERT INTO {{NameSQL $modelName}}_{{NameSQL $column}}({{$modelName}}_id, {{$column}}_id) VALUES ($1, $2)`, id, {{$column}}.ID); err != nil {
				return err
			}
		}
	}{{end}}{{end}}{{end}}{{end}}
	return nil
}{{end}}

{{if or (eq $method "List") (IsCustomList $method)}}func (a *App) {{$method}}{{$modelName}}(offset, limit int64, filters []*app.Filter) ([]*app.{{$modelName}}, error) { 
	ms := []{{$modelName}}{}
	if err := a.db.Select(&ms, `SELECT {{if  (IsCustomList $method)}}{{(index $model.MethodsProps $i).CustomListSqlSelect}}{{else}}{{$model.SqlSelectStr}}{{end}} FROM {{NameSQL $modelName}}s OFFSET $1 LIMIT $2`, offset, limit); err != nil {
		return nil, err
	}{{if $model.HaveLazyLoading}}{{if  (IsCustomList $method)}}{{if ((index $model.MethodsProps $i).NeedLazyLoading)}}
	for i := range ms {
		if err := ms[i].LazyLoading{{$method}}(a); err != nil {
			return nil, err
		}
	}{{end}}{{else}}
	for i := range ms {
		if err := ms[i].LazyLoading(a); err != nil {
			return nil, err
		}
	}{{end}}{{end}}

	if len(filters) != 0 {
		res := []{{$modelName}}{}
		for _, m := range ms {
			count := 0
			for _, f := range filters {
				switch strings.Title(strings.ToLower(f.Key)) {
				{{range $column, $options := $model.Columns}}
				{{if eq $options.TitleName "ID"}}case "Id":
				value, err := strconv.ParseInt(f.Value, 10, 64)
				if err != nil {
					return nil, err
				}
				count += filterCount(f.Include, m.ID, value){{else}}
				{{if eq $options.GoType "bool"}}
				case "{{$options.TitleName}}":
					var value bool
					switch f.Value {
					case "true":
						value = true
					case "false":
						value = false
					default:
						return nil, errors.Errorf(`failed to parse string value of enabled "%v" to bool type`, f.Value)
					}
					count += filterCount(f.Include, m.{{$options.TitleName}}, value)
				{{else}}
				{{if $options.IsStruct}}case "{{$options.TitleName}}":
					value, err := strconv.ParseInt(f.Value, 10, 64)
					if err != nil {
						return nil, err
					}{{if $options.IsArray}}
					for _, {{$column}} := range m.{{$options.TitleName}} {
						count += filterCount(f.Include, {{$column}}.ID, value)
					}
					{{else}}
					count += filterCount(f.Include, m.{{$options.TitleName}}ID, value){{end}}{{else}}
				case "{{$options.TitleName}}":
					count += filterCount(f.Include, m.{{$options.TitleName}}, f.Value)
				{{end}}{{end}}{{end}}{{end}}
				}
			}
			if count == len(filters) {
				res = append(res, m)
			}
		}
		ms = res
	}

	return app{{$modelName}}s(ms), nil
}{{end}}
{{if and (IsCustomList $method) ((index $model.MethodsProps $i).NeedLazyLoading)}}{{range $j, $nestedObj := (index $model.MethodsProps $i).NestedObjs}}
{{if $nestedObj.IsFirstForLazyLoading}}func (m *{{if $nestedObj.Path}}{{$nestedObj.ParentStruct}}{{else}}{{$modelName}}{{end}}) LazyLoading{{$method}}{{$nestedObj.Path}}(a *App) error { {{end}} {{$model2 := (index $.Models $nestedObj.Name)}}{{$options := (index $model2.Columns (LowerTitle $nestedObj.Name))}}{{if  $nestedObj.IsArray}}
	slice{{$options.TitleName}} := []{{if $nestedObj.Path}}{{$nestedObj.ParentStruct}}{{else}}{{$modelName}}{{end}}{{$nestedObj.Type}}{}
	if err := a.db.Select(&slice{{$options.TitleName}}, `SELECT * FROM {{if $nestedObj.Path}}{{NameSQL $nestedObj.ParentStruct}}{{else}}{{NameSQL $modelName}}{{end}}_{{NameSQL $nestedObj.Name}} WHERE {{if $nestedObj.Path}}{{$nestedObj.ParentStruct}}{{else}}{{$modelName}}{{end}}_id=$1`, m.ID); err != nil {
		return err
	}
	for _, cd := range slice{{$options.TitleName}} {
		var elem {{$nestedObj.Type}}
		if err := a.db.Get(&elem, `SELECT {{$nestedObj.SqlSelect}} FROM {{NameSQL $nestedObj.Type}}s WHERE id=$1`, cd. {{$nestedObj.Type}}ID); err != nil {
			return err
		}
		{{if $nestedObj.NeedLazyLoading}}
		if err := elem.LazyLoading{{$method}}{{$nestedObj.Path}}{{$nestedObj.Name}}(a); err != nil {
			return err
		}{{end}}
		m.{{$nestedObj.Name}} = append(m.{{$nestedObj.Name}}, elem)
	}{{else}}
	if err := a.db.Get(&m.{{$nestedObj.Name}}, `SELECT {{$nestedObj.SqlSelect}} FROM {{NameSQL $nestedObj.Type}}s WHERE id=$1`, m.{{$nestedObj.Name}}ID); err != nil {
		return err
	}{{if $nestedObj.NeedLazyLoading}}
	if err := m.{{$nestedObj.Name}}.LazyLoading{{$method}}{{$nestedObj.Name}}(a); err != nil {
		return err
	}{{end}}{{end}}
	{{if $nestedObj.IsLastForLazyLoading}}
	return nil
}{{end}}
{{end}}{{end}}
{{if  and (ne $method "Get") (ne $method "Add") (ne $method "Delete") (ne $method "Edit") (ne $method "List") (not (IsCustomList $method))}}
func (a *App) {{$method}}{{$modelName}}(m *app.{{$modelName}}) error {
	return nil
}{{end}}
{{end}}

{{if $model.HaveLazyLoading}}
func (m *{{$modelName}}) LazyLoading(a *App) error { {{range $modelName2, $model2 := $.Models}}{{range $column, $options := $model.Columns}}{{if eq $modelName2 $options.GoType}}{{if  $options.IsArray}}
	slice{{$options.TitleName}} := []{{$modelName}}{{$options.GoType}}{}
	if err := a.db.Select(&slice{{$options.TitleName}}, `SELECT * FROM {{NameSQL $modelName}}_{{NameSQL $options.TitleName}} WHERE {{$modelName}}_id=$1`, m.ID); err != nil {
		return err
	}
	for _, cd := range slice{{$options.TitleName}} {
		var {{$column}} {{$options.GoType}}
		if err := a.db.Get(&{{$column}}, `SELECT {{$model2.SqlSelectStr}} FROM {{NameSQL $options.GoType}}s WHERE id=$1`, cd.{{$options.GoType}}ID); err != nil {
			return err
		}{{if $model2.HaveLazyLoading}}
		if err := {{$column}}.LazyLoading(a); err != nil {
			return err
		}{{end}}
		m.{{$options.TitleName}} = append(m.{{$options.TitleName}}, {{$column}})
	}{{else}}
	if err := a.db.Get(&m.{{$options.TitleName}}, `SELECT {{$model2.SqlSelectStr}} FROM {{NameSQL $modelName2}}s WHERE id=$1`, m.{{$options.TitleName}}ID); err != nil {
		return err
	}{{if $model2.HaveLazyLoading}}
	if err := m.{{$options.TitleName}}.LazyLoading(a); err != nil {
		return err
	}{{end}}{{end}}{{end}}{{end}}{{end}}
	return nil
}
{{end}}
{{range $functionName, $function := $.Functions}}
func (a *App) {{$functionName}}{{$modelName}}({{$function.InStrFull}}) ({{$function.OutStrType}}, error){
	{{range $name, $type := $function.Out}}var {{$name}} {{$type}}
	{{end}}
	/* Example:
	if err := a.db.Get(&key, `SELECT key FROM components WHERE title=$1`, serviceName); err != nil {
		return "", err
	}*/

	return {{$function.OutStr}}, nil
}{{end}}

func app{{$modelName}}(m {{$modelName}}) *app.{{$modelName}} {
	return &app.{{$modelName}}{ {{range $name, $options := $model.Columns}}
		{{$options.TitleName}}: {{if $options.IsStruct}}app{{$options.GoType}}{{if $options.IsArray}}s{{end}}(m.{{$options.TitleName}}){{else}}m.{{$options.TitleName}}{{if and $model.IDIsUUID (eq $options.TitleName "ID")}}.String(){{end}}{{end}}, {{end}}
	}
}

func app{{$modelName}}s(ms []{{$modelName}}) []*app.{{$modelName}} {
	ams := []*app.{{$modelName}}{}
	for _, m := range ms {
		ams = append(ams, app{{$modelName}}(m))
	}

	return ams
}

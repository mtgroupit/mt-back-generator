// Code generated by mtgroup-generator.  {{$modelName := .CurModel}} {{$model := (index $.Models $modelName)}} {{$models := .Models}}
package dal

import (
	"{{.Module}}/internal/app"

	{{if $model.IDIsUUID}}"github.com/google/uuid"{{else}}{{$inputed := false}}{{range $name, $options := $model.Columns}}{{$model2 := (index $.Models $options.GoType)}}{{if and $model2.IDIsUUID (not $inputed) (not $options.IsArray)}}"github.com/google/uuid"{{$inputed = true}}{{end}}{{end}}{{end}}
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

type {{$modelName}} struct { {{range $i, $psqlParams := $model.Psql}}{{if $psqlParams.IsStruct}}
	{{if not $psqlParams.IsArray}}{{$psqlParams.Name}}ID {{if eq  $psqlParams.TypeSQL "uuid"}}uuid.UUID{{else}}int64{{end}} `db:"{{$psqlParams.SQLName}}"`{{end}}
	{{$psqlParams.Name}} {{if $psqlParams.IsArray}}[]{{end}}{{$psqlParams.Type}}{{else}}
	{{$psqlParams.Name}} {{if eq  $psqlParams.TypeSQL "uuid"}}uuid.UUID{{else}}{{$psqlParams.Type}}{{end}} `db:"{{$psqlParams.SQLName}}"` {{end}}{{end}}
}

{{range $i, $method := $model.Methods}}
{{if eq $method "Get"}}func (a *App) {{$method}}{{$modelName}}(id {{if $model.IDIsUUID}}string{{else}}int64{{end}}) (*app.{{$modelName}}, error) { 
	var m {{$modelName}}
	if err := a.db.Get(&m, `SELECT {{$model.SQLSelectStr}} FROM {{NameSQL $modelName}}s WHERE id=$1`, id); err != nil {
		return nil, err
	}{{if $model.HaveLazyLoading}}
	if err := m.LazyLoading(a); err != nil {
		return nil, err
	}{{end}}
	return app{{$modelName}}(m), nil
}{{end}}
{{if eq $method "Add"}}func (a *App) {{$method}}{{$modelName}}(m *app.{{$modelName}}) error {
	{{if $model.IDIsUUID}}{{$modelName}}ID := uuid.New(){{else}}var {{$modelName}}ID int64{{end}}	{{range $column, $options := $model.Columns}}{{if and $options.IsStruct (not $options.IsArray)}}
	var {{$column}}ID interface{}
	if m.{{$options.TitleName}} != nil {
		{{$column}}ID = m.{{$options.TitleName}}.ID
	}{{end}}{{end}}
	if err := a.db.Get(&{{$modelName}}ID, `INSERT INTO {{NameSQL $modelName}}s{{$model.SQLAddStr}} RETURNING id`, {{$model.SQLExecParams}}{{if $model.IDIsUUID}}, {{$modelName}}ID{{end}}); err != nil {
		return err
	}{{range $modelName2, $model2 := $.Models}}{{range $column, $options := $model.Columns}}{{if eq $modelName2 $options.GoType}}{{if $options.IsArray}}
	for _, m := range m.{{$options.TitleName}} {
		if _, err := a.db.Exec(`INSERT INTO {{NameSQL $modelName}}_{{NameSQL $column}}({{NameSQL $modelName}}_id, {{NameSQL $column}}_id) VALUES ($1, $2)`, {{$modelName}}ID, m.ID); err != nil {
			return err
		}
	}{{end}}{{end}}{{end}}{{end}}
	return nil
}{{end}}
{{if eq $method "Delete"}}func (a *App) {{$method}}{{$modelName}}(id {{if $model.IDIsUUID}}string{{else}}int64{{end}}) error { {{range $modelName2, $model2 := $.Models}}{{range $column, $options := $model.Columns}}{{if eq $modelName2 $options.GoType}}{{if $options.IsArray}}
	if _, err := a.db.Exec(`DELETE FROM {{NameSQL $modelName}}_{{NameSQL $column}} WHERE {{NameSQL $modelName}}_id=$1`, id); err != nil {
		return err
	}{{end}}{{end}}{{end}}{{end}} {{range $_, $bind := $model.Binds}}{{if $bind.IsArray}}
	if _, err := a.db.Exec(`DELETE FROM {{NameSQL $bind.ModelName}}_{{NameSQL $bind.FieldName}} WHERE {{NameSQL $bind.FieldName}}_id=$1`, id); err != nil {
		return err
	}{{else}}
	if _, err := a.db.Exec(`UPDATE {{NameSQL $bind.ModelName}}s SET {{$bind.FieldName}}_id=NULL WHERE {{NameSQL $bind.FieldName}}_id=$1`, id); err != nil {
		return err
	}{{end}}{{end}}
	if _, err := a.db.Exec(`DELETE FROM {{NameSQL $modelName}}s WHERE id=$1`, id); err != nil {
		return err
	}
	return nil
}{{end}}
{{if eq $method "Edit"}}func (a *App) {{$method}}{{$modelName}}(id {{if $model.IDIsUUID}}string{{else}}int64{{end}}, m *app.{{$modelName}}) error  { {{range $column, $options := $model.Columns}}{{if and $options.IsStruct (not $options.IsArray)}}
	var {{$column}}ID interface{}
	if m.{{$options.TitleName}} != nil {
		{{$column}}ID = m.{{$options.TitleName}}.ID
	}{{end}}{{end}}
	if _, err := a.db.Exec(`UPDATE {{NameSQL $modelName}}s SET {{$model.SQLEditStr}} WHERE id=$1`, id, {{$model.SQLExecParams}}); err != nil {
		return err
	}{{range $modelName2, $model2 := $.Models}}{{range $column, $options := $model.Columns}}{{if eq $modelName2 $options.GoType}}{{if $options.IsArray}}
	if len(m.{{$options.TitleName}}) != 0 {
		if _, err := a.db.Exec(`DELETE FROM {{NameSQL $modelName}}_{{NameSQL $column}} WHERE {{NameSQL $modelName}}_id=$1`, id); err != nil {
			return err
		}
		for _, {{$column}} := range m.{{$options.TitleName}} {
			if _, err := a.db.Exec(`INSERT INTO {{NameSQL $modelName}}_{{NameSQL $column}}({{NameSQL $modelName}}_id, {{NameSQL $column}}_id) VALUES ($1, $2)`, id, {{$column}}.ID); err != nil {
				return err
			}
		}
	}{{end}}{{end}}{{end}}{{end}}
	return nil
}{{end}}

{{if or (eq $method "List") (IsCustomList $method)}}func (a *App) {{$method}}{{$modelName}}(offset, limit int64, filters []*app.Filter) ([]*app.{{$modelName}}, error) { 
	ms := []{{$modelName}}{}

	mapQuery := map[string]interface{}{ {{if IsCustomList $method}}{{range $_, $column := (index $model.MethodsProps $i).FilteredFields}}
		"{{$column}}": nil,
		"not_{{$column}}": nil,{{end}}{{else}}{{range $column, $options := $model.Columns}}{{if not $options.IsArray}}
		"{{$column}}": nil,
		"not_{{$column}}": nil,{{end}}{{end}}{{end}}
		"offset": offset,
		"limit": limit,
	}
	{{if or (index $model.MethodsProps $i).FilteredFields (not (IsCustomList $method))}}
	for _, filter := range filters {
		switch filter.Key { {{if IsCustomList $method}}{{range $_, $column := (index $model.MethodsProps $i).FilteredFields}}
		case "{{$column}}":
			if filter.Include {
				mapQuery["{{$column}}"] = filter.Value
			} else {
				mapQuery["not_{{$column}}"] = filter.Value
			}{{end}}{{else}}{{range $column, $options := $model.Columns}}{{if not $options.IsArray}}
		case "{{$column}}":
			if filter.Include {
				mapQuery["{{$column}}"] = filter.Value
			} else {
				mapQuery["not_{{$column}}"] = filter.Value
			}{{end}}{{end}}{{end}}
		default:
			continue
		}
	}{{end}}
	
	rows, err := a.db.NamedQuery(`SELECT {{if  (IsCustomList $method)}}{{(index $model.MethodsProps $i).CustomListSQLSelect}}{{else}}{{$model.SQLSelectStr}}{{end}} FROM {{NameSQL $modelName}}s {{if or (index $model.MethodsProps $i).FilteredFields (not (IsCustomList $method))}}WHERE {{end}}{{if  (IsCustomList $method)}}{{(index $model.MethodsProps $i).CustomListSQLWhereProps}}{{else}}{{$model.SQLWhereParams}}{{end}} OFFSET :offset LIMIT :limit`, mapQuery)
	if err != nil {
		return nil, err
	}
	for rows.Next() {
		var m {{$modelName}}
		err = rows.StructScan(&m)
		ms = append(ms, m)
	}
	
	{{if $model.HaveLazyLoading}}{{if  (IsCustomList $method)}}{{if ((index $model.MethodsProps $i).NeedLazyLoading)}}
	for i := range ms {
		if err := ms[i].LazyLoading{{$method}}(a); err != nil {
			return nil, err
		}
	}{{end}}{{else}}
	for i := range ms {
		if err := ms[i].LazyLoading(a); err != nil {
			return nil, err
		}
	}{{end}}{{end}}

	return app{{$modelName}}s(ms), nil
}{{end}}
{{if and (IsCustomList $method) ((index $model.MethodsProps $i).NeedLazyLoading)}}{{range $j, $nestedObj := (index $model.MethodsProps $i).NestedObjs}}
{{if $nestedObj.IsFirstForLazyLoading}}func (m *{{if $nestedObj.Path}}{{$nestedObj.ParentStruct}}{{else}}{{$modelName}}{{end}}) LazyLoading{{$method}}{{$nestedObj.Path}}(a *App) (err error) { {{end}} {{$model2 := (index $.Models $nestedObj.Name)}}{{$options := (index $model2.Columns (LowerTitle $nestedObj.Name))}}{{if  $nestedObj.IsArray}}
	slice{{$options.TitleName}} := []{{if $nestedObj.Path}}{{$nestedObj.ParentStruct}}{{else}}{{$modelName}}{{end}}{{$nestedObj.Type}}{}
	if err = a.db.Select(&slice{{$options.TitleName}}, `SELECT * FROM {{if $nestedObj.Path}}{{NameSQL $nestedObj.ParentStruct}}{{else}}{{NameSQL $modelName}}{{end}}_{{NameSQL $nestedObj.Name}} WHERE {{if $nestedObj.Path}}{{NameSQL $nestedObj.ParentStruct}}{{else}}{{NameSQL $modelName}}{{end}}_id=$1`, m.ID); err != nil {
		return
	}
	for _, cd := range slice{{$options.TitleName}} {
		var elem {{$nestedObj.Type}}
		if err = a.db.Get(&elem, `SELECT {{$nestedObj.SQLSelect}} FROM {{NameSQL $nestedObj.Type}}s WHERE id=$1`, cd. {{$nestedObj.Type}}ID); err != nil {
			return
		}
		{{if $nestedObj.NeedLazyLoading}}
		if err == nil {
			if err = elem.LazyLoading{{$method}}{{$nestedObj.Path}}{{$nestedObj.Name}}(a); err != nil {
				return
			}
		}{{end}}
		m.{{$nestedObj.Name}} = append(m.{{$nestedObj.Name}}, elem)
	}{{else}}
	if err = a.db.Get(&m.{{$nestedObj.Name}}, `SELECT {{$nestedObj.SQLSelect}} FROM {{NameSQL $nestedObj.Type}}s WHERE id=$1`, m.{{$nestedObj.Name}}ID); err != nil && err.Error() != "sql: no rows in result set" {
		return
	}{{if $nestedObj.NeedLazyLoading}}
	if err == nil {
		if err = m.{{$nestedObj.Name}}.LazyLoading{{$method}}{{$nestedObj.Name}}(a); err != nil {
			return
		}
	}{{end}}{{end}}
	{{if $nestedObj.IsLastForLazyLoading}}
	return nil
}{{end}}
{{end}}{{end}}
{{if  and (ne $method "Get") (ne $method "Add") (ne $method "Delete") (ne $method "Edit") (ne $method "List") (not (IsCustomList $method))}}
func (a *App) {{$method}}{{$modelName}}(m *app.{{$modelName}}) error {
	return nil
}{{end}}
{{end}}

{{if $model.HaveLazyLoading}}
func (m *{{$modelName}}) LazyLoading(a *App) (err error) { {{range $modelName2, $model2 := $.Models}}{{range $column, $options := $model.Columns}}{{if eq $modelName2 $options.GoType}}{{if  $options.IsArray}}
	slice{{$options.TitleName}} := []{{$modelName}}{{$options.GoType}}{}
	if err = a.db.Select(&slice{{$options.TitleName}}, `SELECT * FROM {{NameSQL $modelName}}_{{NameSQL $options.TitleName}} WHERE {{NameSQL $modelName}}_id=$1`, m.ID); err != nil {
		return
	}
	for _, cd := range slice{{$options.TitleName}} {
		var {{$column}} {{$options.GoType}}
		if err = a.db.Get(&{{$column}}, `SELECT {{$model2.SQLSelectStr}} FROM {{NameSQL $options.GoType}}s WHERE id=$1`, cd.{{$options.GoType}}ID); err != nil {
			return
		}{{if $model2.HaveLazyLoading}}
		if err == nil {
			if err = {{$column}}.LazyLoading(a); err != nil {
				return
			}
		}{{end}}
		m.{{$options.TitleName}} = append(m.{{$options.TitleName}}, {{$column}})
	}{{else}}
	if err = a.db.Get(&m.{{$options.TitleName}}, `SELECT {{$model2.SQLSelectStr}} FROM {{NameSQL $modelName2}}s WHERE id=$1`, m.{{$options.TitleName}}ID); err != nil && err.Error() != "sql: no rows in result set" {
		return
	}{{if $model2.HaveLazyLoading}}
	if err == nil {
		if err = m.{{$options.TitleName}}.LazyLoading(a); err != nil {
			return
		}
	}{{end}}{{end}}{{end}}{{end}}{{end}}
	return nil
}
{{end}}
func (a *App) {{$modelName}}AccessManager(am *app.AccessManager) error {
	if _, err := a.db.Exec(`INSERT INTO {{NameSQL $modelName}}s_access VALUES ($1, $2, $3, $4, $5, $6, $7)`, am.User, am.Group, am.Read, am.Write, am.Delete, am.Add, am.AccessManager); err != nil {
		return err
	}
	return nil
}
{{range $functionName, $function := $.Functions}}
func (a *App) {{$functionName}}{{$modelName}}({{$function.InStrFull}}) ({{$function.OutStrType}}, error){
	{{range $name, $type := $function.Out}}var {{$name}} {{$type}}
	{{end}}
	/* Example:
	if err := a.db.Get(&key, `SELECT key FROM components WHERE title=$1`, serviceName); err != nil {
		return "", err
	}*/

	return {{$function.OutStr}}, nil
}{{end}}

func app{{$modelName}}(m {{$modelName}}) *app.{{$modelName}} {
	return &app.{{$modelName}}{ {{range $name, $options := $model.Columns}}
		{{$options.TitleName}}: {{if $options.IsStruct}}app{{$options.GoType}}{{if $options.IsArray}}s{{end}}(m.{{$options.TitleName}}){{else}}m.{{$options.TitleName}}{{if and $model.IDIsUUID (eq $options.TitleName "ID")}}.String(){{end}}{{end}}, {{end}}
	}
}

func app{{$modelName}}s(ms []{{$modelName}}) []*app.{{$modelName}} {
	ams := []*app.{{$modelName}}{}
	for _, m := range ms {
		ams = append(ams, app{{$modelName}}(m))
	}

	return ams
}

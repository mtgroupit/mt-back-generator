// Code generated by mtgroup-generator.
package dal

import (
	"context"
	"database/sql"
	"time"

	"{{.Module}}/migration"

	{{$inputed := false}}{{range $modelName, $model := $.Models}}{{if and $model.IDIsUUID (not $inputed)}}"github.com/google/uuid"{{$inputed = true}}{{end}}{{end}}
	"github.com/jmoiron/sqlx"
	"github.com/pkg/errors"
	"github.com/powerman/pqx"
	"github.com/powerman/sqlxx"
	"github.com/powerman/structlog"
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

const (
	dbTimeout       = 3 * time.Second
	dbIdleTimeout   = 10 * time.Second
	dbMaxOpenConns  = 30 // about â…“ of server's max_connections
	dbParallelConns = 5  // a bit more than average
)

var log = structlog.New()

type App struct {
	db *sqlxx.DB
}
{{range $i, $et := $.ExtraTables}}
type {{$et.RefTableOne}}{{$et.RefTableTwo}} struct{
    {{$et.RefTableOne}}ID {{if eq  $et.TypeIDOne "uuid"}}uuid.UUID{{else}}int64{{end}}  `db:"{{$et.FieldIDOne}}"`
    {{$et.RefTableTwo}}ID {{if eq  $et.TypeIDTwo "uuid"}}uuid.UUID{{else}}int64{{end}}  `db:"{{$et.FieldIDTwo}}"`
}
{{end}}

func connect(ctx context.Context, cfg pqx.Config, migrationDir string) (*sqlxx.DB, error) {
	if err := migration.Up(ctx, migrationDir, cfg); err != nil {
		return nil, err
	}

	cfg.DefaultTransactionIsolation = sql.LevelSerializable
	cfg.StatementTimeout = dbTimeout
	cfg.LockTimeout = dbTimeout
	cfg.IdleInTransactionSessionTimeout = dbIdleTimeout

	db, err := sql.Open("postgres", cfg.FormatDSN())
	if err != nil {
		return nil, err
	}
	db.SetMaxOpenConns(dbMaxOpenConns)
	db.SetMaxIdleConns(dbParallelConns)

	err = db.PingContext(ctx)
	for err != nil {
		nextErr := db.PingContext(ctx)
		if nextErr == context.DeadlineExceeded {
			log.WarnIfFail(db.Close)
			return nil, errors.Wrap(err, "connect to postgres")
		}
		err = nextErr
	}

	return sqlxx.NewDB(sqlx.NewDb(db, "postgres")), nil
}

func New(ctx context.Context, dbCfg pqx.Config, migrationDir string) (*App, error) {
	db, err := connect(ctx, dbCfg, migrationDir)
	if err != nil {
		return nil, err
	}
	return &App{
		db: db,
	}, nil
}

func (a *App) Close() {
	log.WarnIfFail(a.db.Close)
}

{{if .HaveListMethod}}
func filterCount(include bool, a, b interface{}) int {
	if include {
		if a == b {
			return 1
		}
	} else {
		if !(a == b) {
			return 1
		}
	}
	return 0
}{{end}}

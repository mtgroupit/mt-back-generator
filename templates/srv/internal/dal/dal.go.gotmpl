// Code generated by mtgroup-generator.
package dal

import (
	"context"
	"database/sql"
	{{if .HaveListMethod}}"strings"
	"strconv"{{end}}
	"time"

	"{{.Name}}/internal/app"
	"{{.Name}}/migration"

	"github.com/jmoiron/sqlx"
	"github.com/pkg/errors"
	"github.com/powerman/pqx"
	"github.com/powerman/sqlxx"
	"github.com/powerman/structlog"
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

const (
	dbTimeout       = 3 * time.Second
	dbIdleTimeout   = 10 * time.Second
	dbMaxOpenConns  = 30 // about â…“ of server's max_connections
	dbParallelConns = 5  // a bit more than average
)

var log = structlog.New()

type App struct {
	db *sqlxx.DB
}
{{range $modelName, $model := $.Models}}
type {{$modelName}} struct { {{range $i, $psqlParams := $model.Psql}}{{if $psqlParams.IsStruct}}
	{{if not $psqlParams.IsArray}}{{$psqlParams.Name}}ID int64 `db:"{{$psqlParams.SqlName}}"`{{end}}
	{{$psqlParams.Name}} {{if $psqlParams.IsArray}}[]{{end}}{{$psqlParams.Type}}{{else}}
	{{$psqlParams.Name}} {{$psqlParams.Type}} `db:"{{$psqlParams.SqlName}}"` {{end}}{{end}}
} {{end}}
{{range $i, $et := $.ExtraTables}}
type {{$et.RefTableOne}}{{$et.RefTableTwo}} struct{
    {{$et.RefTableOne}}ID int64  `db:"{{$et.FieldIDOne}}"`
    {{$et.RefTableTwo}}ID int64  `db:"{{$et.FieldIDTwo}}"`
}
{{end}}

func connect(ctx context.Context, cfg pqx.Config, migrationDir string) (*sqlxx.DB, error) {
	if err := migration.Up(ctx, migrationDir, cfg); err != nil {
		return nil, err
	}

	cfg.DefaultTransactionIsolation = sql.LevelSerializable
	cfg.StatementTimeout = dbTimeout
	cfg.LockTimeout = dbTimeout
	cfg.IdleInTransactionSessionTimeout = dbIdleTimeout

	db, err := sql.Open("postgres", cfg.FormatDSN())
	if err != nil {
		return nil, err
	}
	db.SetMaxOpenConns(dbMaxOpenConns)
	db.SetMaxIdleConns(dbParallelConns)

	err = db.PingContext(ctx)
	for err != nil {
		nextErr := db.PingContext(ctx)
		if nextErr == context.DeadlineExceeded {
			log.WarnIfFail(db.Close)
			return nil, errors.Wrap(err, "connect to postgres")
		}
		err = nextErr
	}

	return sqlxx.NewDB(sqlx.NewDb(db, "postgres")), nil
}

func New(ctx context.Context, dbCfg pqx.Config, migrationDir string) (*App, error) {
	db, err := connect(ctx, dbCfg, migrationDir)
	if err != nil {
		return nil, err
	}
	return &App{
		db: db,
	}, nil
}

func (a *App) Close() {
	log.WarnIfFail(a.db.Close)
}

{{range $modelName, $model := $.Models}}{{range $i, $method := $model.Methods}}
{{if eq $method "Get"}}func (a *App) {{$method}}{{$modelName}}(id int64) (*app.{{$modelName}}, error) { 
	var m {{$modelName}}
	if err := a.db.Get(&m, `SELECT {{$model.SqlSelectStr}} FROM {{$modelName}}s WHERE {{$model.FirstLetter}}_id=$1`, id); err != nil {
		return nil, err
	}{{if $model.HaveLazyLoading}}
	if err := m.LazyLoading(a); err != nil {
		return nil, err
	}{{end}}
	return app{{$modelName}}(m), nil
}{{end}}
{{if eq $method "Add"}}func (a *App) {{$method}}{{$modelName}}(m *app.{{$modelName}}) error {
	var {{$modelName}}ID int64
	if err := a.db.Get(&{{$modelName}}ID, `INSERT INTO {{$modelName}}s{{$model.SqlAddStr}} RETURNING {{$model.FirstLetter}}_id`, {{$model.SqlExecParams}}); err != nil {
		return err
	}{{range $modelName2, $model2 := $.Models}}{{range $column, $options := $model.Columns}}{{if eq $modelName2 $options.GoType}}{{if $options.IsArray}}
	for _, m := range m.{{$options.TitleName}} {
		if _, err := a.db.Exec(`INSERT INTO {{$modelName}}_{{$column}}({{$modelName}}_id, {{$column}}_id) VALUES ($1, $2)`, {{$modelName}}ID, m.ID); err != nil {
			return err
		}
	}{{end}}{{end}}{{end}}{{end}}
	return nil
}{{end}}
{{if eq $method "Delete"}}func (a *App) {{$method}}{{$modelName}}(id int64) error { {{range $modelName2, $model2 := $.Models}}{{range $column, $options := $model.Columns}}{{if eq $modelName2 $options.GoType}}{{if $options.IsArray}}
	if _, err := a.db.Exec(`DELETE FROM {{$modelName}}_{{$column}} WHERE {{$modelName}}_id=$1`, id); err != nil {
		return err
	}{{end}}{{end}}{{end}}{{end}} {{range $_, $bind := $model.Binds}}{{if $bind.IsArray}}
	if _, err := a.db.Exec(`DELETE FROM {{$bind.ModelName}}_{{$bind.FieldName}} WHERE {{$bind.FieldName}}_id=$1`, id); err != nil {
		return err
	}{{else}}
	if _, err := a.db.Exec(`UPDATE {{$bind.ModelName}}s SET {{$bind.FieldName}}_id=NULL WHERE {{$bind.FieldName}}_id=$1`, id); err != nil {
		return err
	}{{end}}{{end}}
	if _, err := a.db.Exec(`DELETE FROM {{$modelName}}s WHERE {{$model.FirstLetter}}_id=$1`, id); err != nil {
		return err
	}
	return nil
}{{end}}
{{if eq $method "Edit"}}func (a *App) {{$method}}{{$modelName}}(id int64, m *app.{{$modelName}}) error  {
	if _, err := a.db.Exec(`UPDATE {{$modelName}}s SET {{$model.SqlEditStr}} WHERE {{$model.FirstLetter}}_id=$1`, id, {{$model.SqlExecParams}}); err != nil {
		return err
	}{{range $modelName2, $model2 := $.Models}}{{range $column, $options := $model.Columns}}{{if eq $modelName2 $options.GoType}}{{if $options.IsArray}}
	if len(m.{{$options.TitleName}}) != 0 {
		if _, err := a.db.Exec(`DELETE FROM {{$modelName}}_{{$column}} WHERE {{$modelName}}_id=$1`, id); err != nil {
			return err
		}
		for _, {{$column}} := range m.{{$options.TitleName}} {
			if _, err := a.db.Exec(`INSERT INTO {{$modelName}}_{{$column}}({{$modelName}}_id, {{$column}}_id) VALUES ($1, $2)`, id, {{$column}}.ID); err != nil {
				return err
			}
		}
	}{{end}}{{end}}{{end}}{{end}}
	return nil
}{{end}}

{{if or (eq $method "List") (IsCustomList $method)}}func (a *App) {{$method}}{{$modelName}}(offset, limit int64, filters []*app.Filter) ([]*app.{{$modelName}}, error) { 
	ms := []{{$modelName}}{}
	if err := a.db.Select(&ms, `SELECT {{if  (IsCustomList $method)}}{{(index $model.MethodsProps $i).CustomListSqlSelect}}{{else}}{{$model.SqlSelectStr}}{{end}} FROM {{$modelName}}s OFFSET $1 LIMIT $2`, offset, limit); err != nil {
		return nil, err
	}{{if $model.HaveLazyLoading}}{{if  (IsCustomList $method)}}{{if ((index $model.MethodsProps $i).NeedLazyLoading)}}
	for i := range ms {
		if err := ms[i].LazyLoading{{$method}}(a); err != nil {
			return nil, err
		}
	}{{end}}{{else}}
	for i := range ms {
		if err := ms[i].LazyLoading(a); err != nil {
			return nil, err
		}
	}{{end}}{{end}}

	if len(filters) != 0 {
		res := []{{$modelName}}{}
		for _, m := range ms {
			count := 0
			for _, f := range filters {
				switch strings.Title(strings.ToLower(f.Key)) {
				{{range $column, $options := $model.Columns}}
				{{if eq $options.TitleName "ID"}}case "Id":
				value, err := strconv.ParseInt(f.Value, 10, 64)
				if err != nil {
					return nil, err
				}
				count += filterCount(f.Include, m.ID, value){{else}}
				{{if eq $options.GoType "bool"}}
				case "{{$options.TitleName}}":
					var value bool
					switch f.Value {
					case "true":
						value = true
					case "false":
						value = false
					default:
						return nil, errors.Errorf(`failed to parse string value of enabled "%v" to bool type`, f.Value)
					}
					count += filterCount(f.Include, m.{{$options.TitleName}}, value)
				{{else}}
				{{if $options.IsStruct}}case "{{$options.TitleName}}":
					value, err := strconv.ParseInt(f.Value, 10, 64)
					if err != nil {
						return nil, err
					}{{if $options.IsArray}}
					for _, {{$column}} := range m.{{$options.TitleName}} {
						count += filterCount(f.Include, {{$column}}.ID, value)
					}
					{{else}}
					count += filterCount(f.Include, m.{{$options.TitleName}}ID, value){{end}}{{else}}
				case "{{$options.TitleName}}":
					count += filterCount(f.Include, m.{{$options.TitleName}}, f.Value)
				{{end}}{{end}}{{end}}{{end}}
				}
			}
			if count == len(filters) {
				res = append(res, m)
			}
		}
		ms = res
	}

	return app{{$modelName}}s(ms), nil
}{{end}}
{{if and (IsCustomList $method) ((index $model.MethodsProps $i).NeedLazyLoading)}}{{range $j, $nestedObj := (index $model.MethodsProps $i).NestedObjs}}
{{if $nestedObj.IsFirstForLazyLoading}}func (m *{{if $nestedObj.Path}}{{$nestedObj.ParentStruct}}{{else}}{{$modelName}}{{end}}) LazyLoading{{$method}}{{$nestedObj.Path}}(a *App) error { {{end}} {{$model2 := (index $.Models $nestedObj.Name)}}{{$options := (index $model2.Columns (LowerTitle $nestedObj.Name))}}{{if  $nestedObj.IsArray}}
	slice{{$options.TitleName}} := []{{if $nestedObj.Path}}{{$nestedObj.ParentStruct}}{{else}}{{$modelName}}{{end}}{{$nestedObj.Type}}{}
	if err := a.db.Select(&slice{{$options.TitleName}}, `SELECT * FROM {{if $nestedObj.Path}}{{$nestedObj.ParentStruct}}{{else}}{{$modelName}}{{end}}_{{$nestedObj.Name}} WHERE {{if $nestedObj.Path}}{{$nestedObj.ParentStruct}}{{else}}{{$modelName}}{{end}}_id=$1`, m.ID); err != nil {
		return err
	}
	for _, cd := range slice{{$options.TitleName}} {
		var elem {{$nestedObj.Type}}
		if err := a.db.Get(&elem, `SELECT {{$nestedObj.SqlSelect}} FROM {{$nestedObj.Type}}s WHERE {{$nestedObj.FirstLetter}}_id=$1`, cd. {{$nestedObj.Type}}ID); err != nil {
			return err
		}
		{{if $nestedObj.NeedLazyLoading}}
		if err := elem.LazyLoading{{$method}}{{$nestedObj.Path}}{{$nestedObj.Name}}(a); err != nil {
			return err
		}{{end}}
		m.{{$nestedObj.Name}} = append(m.{{$nestedObj.Name}}, elem)
	}{{else}}
	if err := a.db.Get(&m.{{$nestedObj.Name}}, `SELECT {{$nestedObj.SqlSelect}} FROM {{$nestedObj.Type}}s WHERE {{$nestedObj.FirstLetter}}_id=$1`, m.{{$nestedObj.Name}}ID); err != nil {
		return err
	}{{if $nestedObj.NeedLazyLoading}}
	if err := m.{{$nestedObj.Name}}.LazyLoading{{$method}}{{$nestedObj.Name}}(a); err != nil {
		return err
	}{{end}}{{end}}
	{{if $nestedObj.IsLastForLazyLoading}}
	return nil
}{{end}}
{{end}}{{end}}
{{if  and (ne $method "Get") (ne $method "Add") (ne $method "Delete") (ne $method "Edit") (ne $method "List") (not (IsCustomList $method))}}
func (a *App) {{$method}}{{$modelName}}(m *app.{{$modelName}}) error {
	return nil
}{{end}}
{{end}}{{end}}

{{range $modelName, $model := $.Models}}{{if $model.HaveLazyLoading}}
func (m *{{$modelName}}) LazyLoading(a *App) error { {{range $modelName2, $model2 := $.Models}}{{range $column, $options := $model.Columns}}{{if eq $modelName2 $options.GoType}}{{if  $options.IsArray}}
	slice{{$options.TitleName}} := []{{$modelName}}{{$options.GoType}}{}
	if err := a.db.Select(&slice{{$options.TitleName}}, `SELECT * FROM {{$modelName}}_{{$options.TitleName}} WHERE {{$modelName}}_id=$1`, m.ID); err != nil {
		return err
	}
	for _, cd := range slice{{$options.TitleName}} {
		var {{$column}} {{$options.GoType}}
		if err := a.db.Get(&{{$column}}, `SELECT {{$model2.SqlSelectStr}} FROM {{$options.GoType}}s WHERE {{$model2.FirstLetter}}_id=$1`, cd.{{$options.GoType}}ID); err != nil {
			return err
		}{{if $model2.HaveLazyLoading}}
		if err := {{$column}}.LazyLoading(a); err != nil {
			return err
		}{{end}}
		m.{{$options.TitleName}} = append(m.{{$options.TitleName}}, {{$column}})
	}{{else}}
	if err := a.db.Get(&m.{{$options.TitleName}}, `SELECT {{$model2.SqlSelectStr}} FROM {{$modelName2}}s WHERE {{$model2.FirstLetter}}_id=$1`, m.{{$options.TitleName}}ID); err != nil {
		return err
	}{{if $model2.HaveLazyLoading}}
	if err := m.{{$options.TitleName}}.LazyLoading(a); err != nil {
		return err
	}{{end}}{{end}}{{end}}{{end}}{{end}}
	return nil
}
{{end}}{{end}}



{{if .HaveListMethod}}
func filterCount(include bool, a, b interface{}) int {
	if include {
		if a == b {
			return 1
		}
	} else {
		if !(a == b) {
			return 1
		}
	}
	return 0
}{{end}}
{{range $modelName, $model := $.Models}}{{range $functionName, $function := $.Functions}}
func (a *App) {{$functionName}}{{$modelName}}({{$function.InStrFull}}) ({{$function.OutStrType}}, error){
	{{range $name, $type := $function.Out}}var {{$name}} {{$type}}
	{{end}}
	/* Example:
	if err := a.db.Get(&key, `SELECT c_key FROM components WHERE title=$1`, serviceName); err != nil {
		return "", err
	}*/

	return {{$function.OutStr}}, nil
}{{end}}{{end}}
{{range $modelName, $model := $.Models}}
func app{{$modelName}}(m {{$modelName}}) *app.{{$modelName}} {
	return &app.{{$modelName}}{ {{range $name, $options := $model.Columns}}
		{{$options.TitleName}}: {{if $options.IsStruct}}app{{$options.GoType}}{{if $options.IsArray}}s{{end}}(m.{{$options.TitleName}}){{else}}m.{{$options.TitleName}}{{end}}, {{end}}
	}
}

func app{{$modelName}}s(ms []{{$modelName}}) []*app.{{$modelName}} {
	ams := []*app.{{$modelName}}{}
	for _, m := range ms {
		ams = append(ams, app{{$modelName}}(m))
	}

	return ams
}{{end}}

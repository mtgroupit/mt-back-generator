// Code generated by mtgroup-generator.
package dal

import (
	"context"
	"database/sql"
	"encoding/json"
	"reflect"
	"strconv"
	"strings"
	"time"

	"{{.Module}}/migration"

	{{$inputed := false}}{{range $modelName, $model := $.Models}}{{range $name, $options := $model.Columns}}{{if and $model.IDIsUUID (and $options.IsArray $options.IsStruct) (not $inputed)}}"github.com/google/uuid"{{$inputed = true}}{{end}}{{end}}{{end}}
	"github.com/jmoiron/sqlx"
	"github.com/pkg/errors"
	"github.com/powerman/pqx"
	"github.com/powerman/sqlxx"
	"github.com/powerman/structlog"
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

const (
	dbTimeout       = 3 * time.Second
	dbIdleTimeout   = 10 * time.Second
	dbMaxOpenConns  = 30 // about â…“ of server's max_connections
	dbParallelConns = 5  // a bit more than average
)

var log = structlog.New()

type Repo struct {
	db *DB
}

{{- if .HaveCustomMethod}}
	type CustomsRepo struct {
		db *DB
	}
{{- end}}

{{range $i, $et := $.ExtraTables}}
type {{$et.RefTableOne}}{{$et.RefTableTwo}} struct{
    {{$et.RefTableOne}}ID {{if eq  $et.TypeIDOne "uuid"}}uuid.UUID{{else}}int64{{end}}  `db:"{{$et.FieldIDOne}}"`
    {{$et.RefTableTwo}}ID {{if eq  $et.TypeIDTwo "uuid"}}uuid.UUID{{else}}int64{{end}}  `db:"{{$et.FieldIDTwo}}"`
}
{{end}}

func connect(ctx context.Context, cfg pqx.Config, migrationDir string{{if .Debug}}, resetDB bool{{end}}) (*DB, error) { {{if .Debug}}
	if resetDB {
		if err := migration.ResetAll(ctx, migrationDir, cfg); err != nil {
			return nil, err
		}
	}{{end}}
	if err := migration.Up(ctx, migrationDir, cfg); err != nil {
		return nil, err
	}

	cfg.DefaultTransactionIsolation = sql.LevelSerializable
	cfg.StatementTimeout = dbTimeout
	cfg.LockTimeout = dbTimeout
	cfg.IdleInTransactionSessionTimeout = dbIdleTimeout

	db, err := sql.Open("postgres", cfg.FormatDSN())
	if err != nil {
		return nil, err
	}
	db.SetMaxOpenConns(dbMaxOpenConns)
	db.SetMaxIdleConns(dbParallelConns)

	err = db.PingContext(ctx)
	for err != nil {
		nextErr := db.PingContext(ctx)
		if nextErr == context.DeadlineExceeded {
			log.WarnIfFail(db.Close)
			return nil, errors.Wrap(err, "connect to postgres")
		}
		err = nextErr
	}

	return NewDB(sqlxx.NewDB(sqlx.NewDb(db, "postgres"))), nil
}

func New(ctx context.Context, dbCfg pqx.Config, migrationDir string{{if .Debug}}, resetDB bool{{end}}) (*Repo, {{if .HaveCustomMethod}}*CustomsRepo, {{end}} error) {
	db, err := connect(ctx, dbCfg, migrationDir{{if .Debug}}, resetDB{{end}})
	if err != nil {
		return nil, {{if .HaveCustomMethod}}nil, {{end}}err
	}
	return &Repo{
		db: db,
	}{{if .HaveCustomMethod}}, &CustomsRepo{
		db: db,
	}{{end}}, nil
}

func (a *Repo) Close() {
	log.WarnIfFail(a.db.Close)
}

{{if .HaveListMethod}}
func filterCount(include bool, a, b interface{}) int {
	if include {
		if a == b {
			return 1
		}
	} else {
		if !(a == b) {
			return 1
		}
	}
	return 0
}{{end}}

func toString(value interface{}) string {
	switch value.(type) {
	case string:
		return value.(string)
	case int:
		return strconv.FormatInt(int64(value.(int)), 10)
	case int32:
		return strconv.FormatInt(int64(value.(int32)), 10)
	case int64:
		return strconv.FormatInt(value.(int64), 10)
	case float64:
		return strconv.FormatFloat(value.(float64), 'f', -1, 64)
	case bool:
		if value.(bool) {
			return "true"
		}
		return "false"
	case time.Time:
		return value.(time.Time).String()
	}
	return ""
}

func pagination(offset, limit, len int) (start, end int) {
	if limit == 0 {
		limit = len
	}
	if len > offset {
		start = offset
		if len >= offset+limit {
			end = offset + limit
		} else {
			end = len
		}
	} else {
		start, end = 0, 0
	}
	return
}

// contains is equal to strings.Contains but case insensitive
func contains(str, substr string) bool  {
	return strings.Contains(strings.ToLower(str), strings.ToLower(substr))
}

func areEqualJSON(s1, s2 string) (bool, error) {
	var o1 interface{}
	var o2 interface{}

	var err error
	err = json.Unmarshal([]byte(s1), &o1)
	if err != nil {
		return false, err
	}
	err = json.Unmarshal([]byte(s2), &o2)
	if err != nil {
		return false, err
	}

	return reflect.DeepEqual(o1, o2), nil
}
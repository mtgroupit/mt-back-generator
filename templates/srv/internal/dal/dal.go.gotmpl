// Code generated by mtgroup-generator.
package dal

import (
	"context"
	"database/sql"
	"strconv"
	"time"

	"{{.Module}}/migration"

	{{$inputed := false}}{{range $modelName, $model := $.Models}}{{range $name, $options := $model.Columns}}{{if and $model.IDIsUUID $options.IsArray (not $inputed)}}"github.com/google/uuid"{{$inputed = true}}{{end}}{{end}}{{end}}
	"github.com/jmoiron/sqlx"
	"github.com/pkg/errors"
	"github.com/powerman/pqx"
	"github.com/powerman/sqlxx"
	"github.com/powerman/structlog"
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

const (
	dbTimeout       = 3 * time.Second
	dbIdleTimeout   = 10 * time.Second
	dbMaxOpenConns  = 30 // about â…“ of server's max_connections
	dbParallelConns = 5  // a bit more than average
)

var log = structlog.New()

type App struct {
	db *sqlxx.DB
}
{{if .HaveCustomMethod}}
type Customs struct {
	db *sqlxx.DB
}
{{end}}
{{range $i, $et := $.ExtraTables}}
type {{$et.RefTableOne}}{{$et.RefTableTwo}} struct{
    {{$et.RefTableOne}}ID {{if eq  $et.TypeIDOne "uuid"}}uuid.UUID{{else}}int64{{end}}  `db:"{{$et.FieldIDOne}}"`
    {{$et.RefTableTwo}}ID {{if eq  $et.TypeIDTwo "uuid"}}uuid.UUID{{else}}int64{{end}}  `db:"{{$et.FieldIDTwo}}"`
}
{{end}}

func connect(ctx context.Context, cfg pqx.Config, migrationDir string{{if .Debug}}, resetDB bool{{end}}) (*sqlxx.DB, error) { {{if .Debug}}
	if resetDB {
		if err := migration.DownAll(ctx, migrationDir, cfg); err != nil {
			return nil, err
		}
	}{{end}}
	if err := migration.Up(ctx, migrationDir, cfg); err != nil {
		return nil, err
	}

	cfg.DefaultTransactionIsolation = sql.LevelSerializable
	cfg.StatementTimeout = dbTimeout
	cfg.LockTimeout = dbTimeout
	cfg.IdleInTransactionSessionTimeout = dbIdleTimeout

	db, err := sql.Open("postgres", cfg.FormatDSN())
	if err != nil {
		return nil, err
	}
	db.SetMaxOpenConns(dbMaxOpenConns)
	db.SetMaxIdleConns(dbParallelConns)

	err = db.PingContext(ctx)
	for err != nil {
		nextErr := db.PingContext(ctx)
		if nextErr == context.DeadlineExceeded {
			log.WarnIfFail(db.Close)
			return nil, errors.Wrap(err, "connect to postgres")
		}
		err = nextErr
	}

	return sqlxx.NewDB(sqlx.NewDb(db, "postgres")), nil
}

func New(ctx context.Context, dbCfg pqx.Config, migrationDir string{{if .Debug}}, resetDB bool{{end}}) (*App, {{if .HaveCustomMethod}}*Customs, {{end}}error) {
	db, err := connect(ctx, dbCfg, migrationDir{{if .Debug}}, resetDB{{end}})
	if err != nil {
		return nil,{{if .HaveCustomMethod}} nil, {{end}} err
	}
	return &App{
		db: db,
	},{{if .HaveCustomMethod}} &Customs{
		db: db,
	}, {{end}} nil
}

func (a *App) Close() {
	log.WarnIfFail(a.db.Close)
}

{{if .HaveListMethod}}
func filterCount(include bool, a, b interface{}) int {
	if include {
		if a == b {
			return 1
		}
	} else {
		if !(a == b) {
			return 1
		}
	}
	return 0
}{{end}}

func toString(value interface{}) string {
	switch value.(type) {
	case string:
		return value.(string)
	case int:
		return strconv.FormatInt(int64(value.(int)), 10)
	case int32:
		return strconv.FormatInt(int64(value.(int32)), 10)
	case int64:
		return strconv.FormatInt(value.(int64), 10)
	case bool:
		if value.(bool) {
			return "true"
		}
		return "false"
	}
	return ""
}

// Code generated by mtgroup-generator.
package api

import (
	"context"
	"net/http"
	"path"

	"{{.Module}}/internal/api/restapi/models"
	"{{.Module}}/internal/api/restapi/restapi"
	"{{.Module}}/internal/api/restapi/restapi/operations"
	{{$module := .Module}}
	{{- range $tag, $_ := .Tags}}
		{{$tag}} "{{$module}}/internal/api/restapi/restapi/operations/{{NameSQL $tag}}"
	{{- end}}
	"{{.Module}}/internal/app"
	"github.com/rs/cors"

	"github.com/go-openapi/loads"
	"github.com/go-openapi/runtime/middleware"
	{{- if or .HaveDateTime .HaveEmail}}
		"github.com/go-openapi/strfmt"
	{{- end}}
	"github.com/pkg/errors"
	"github.com/powerman/structlog"
	"github.com/sebest/xff"
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

// Ctx is a synonym for convenience.
type Ctx = context.Context

// Log is a synonym for convenience.
type Log = *structlog.Logger

type Config struct {
	Host       string
	Port       int
	BasePath   string
	AllowedOrigin string
}

type service struct {
	app     app.App
{{- if .HaveCustomMethod}}
	cust    app.Customs
{{- end}}
	extAuth AuthSvc
}

func NewServer(appl app.App,{{if .HaveCustomMethod}}cust app.Customs,{{end}} extAuth AuthSvc, cfg Config) (*restapi.Server, error) {
	svc := &service{
		app:     appl,
	{{- if .HaveCustomMethod}}
		cust:    cust,
	{{- end}}
		extAuth: extAuth,
	}

	swaggerSpec, err := loads.Embedded(restapi.SwaggerJSON, restapi.FlatSwaggerJSON)
	if err != nil {
		return nil, errors.Wrap(err, "failed to load embedded swagger spec")
	}
	if cfg.BasePath == "" {
		cfg.BasePath = swaggerSpec.BasePath()
	}
	swaggerSpec.Spec().BasePath = cfg.BasePath

	api := operations.New{{FormatName .Name}}API(swaggerSpec)

	api.Logger = structlog.New(structlog.KeyUnit, "swagger").Printf
	api.CookieKeyAuth = svc.checkerAuth
	api.CsrfTokenAuth = svc.csrfTokenAuth

	api.HealthCheckHandler = operations.HealthCheckHandlerFunc(healthCheck)
    {{- range $modelName, $model := $.Models}}
		{{- range $i, $method := $model.Methods}}
			api.{{if $model.Tags}}{{(index $model.Tags 0)}}{{end}}{{$method}}{{$model.TitleName}}Handler = {{if $model.Tags}}{{LowerTitle (index $model.Tags 0)}}{{else}}operations{{end}}.{{$method}}{{$model.TitleName}}HandlerFunc(svc.{{$method}}{{$modelName}})
		{{- end}}
		{{- range $column, $options := $model.Columns}}
			{{- if and $options.IsArray $options.IsStruct}}
				api.{{if $model.Tags}}{{(index $model.Tags 0)}}{{end}}Add{{Title $column}}{{$model.TitleName}}Handler = {{if $model.Tags}}{{LowerTitle (index $model.Tags 0)}}{{else}}operations{{end}}.Add{{Title $column}}{{$model.TitleName}}HandlerFunc(svc.Add{{Title $column}}{{$modelName}})
				api.{{if $model.Tags}}{{(index $model.Tags 0)}}{{end}}Delete{{Title $column}}{{$model.TitleName}}Handler = {{if $model.Tags}}{{LowerTitle (index $model.Tags 0)}}{{else}}operations{{end}}.Delete{{Title $column}}{{$model.TitleName}}HandlerFunc(svc.Delete{{Title $column}}{{$modelName}})
			{{- end}}
		{{- end}}
		api.{{if $model.Tags}}{{(index $model.Tags 0)}}{{end}}{{$model.TitleName}}AccessManagerHandler = {{if $model.Tags}}{{LowerTitle (index $model.Tags 0)}}{{else}}operations{{end}}.{{$model.TitleName}}AccessManagerHandlerFunc(svc.{{$model.TitleName}}AccessManager)
	{{- end}}
	{{- range $modelName, $model := $.Models}}
		{{range $function, $_ := $.Functions}}
			api.{{$modelName}}{{$function}}Handler = operations.{{$modelName}}{{$function}}HandlerFunc(svc.{{$function}}{{$modelName}})
		{{- end}}
	{{- end}}

	server := restapi.NewServer(api)
	server.Host = string(cfg.Host)
	server.Port = int(cfg.Port)

	// The middleware executes before anything.
	globalMiddlewares := func(handler http.Handler) http.Handler {
		xffmw, _ := xff.Default()
		logger := makeLogger(cfg.BasePath)
		accesslog := makeAccessLog(cfg.BasePath)
		redocOpts := middleware.RedocOpts{
			BasePath: cfg.BasePath,
			SpecURL:  path.Join(cfg.BasePath, "/swagger.json"),
		}
		return xffmw.Handler(logger(noCache(recovery(accesslog(
			middleware.Spec(cfg.BasePath, restapi.FlatSwaggerJSON,
				middleware.Redoc(redocOpts,
					handler)))))))
	}
	// The middleware executes after serving /swagger.json and routing,
	// but before authentication, binding and validation.
	middlewares := func(handler http.Handler) http.Handler {
		safePath := map[string]bool{
			cfg.BasePath + "/consultation/list": true,
			cfg.BasePath + "/demand/list":       true,
		}
		isSafe := func(r *http.Request) bool { return safePath[r.URL.Path] }
		forbidCSRF := makeForbidCSRF(isSafe)
		return forbidCSRF(handler)
	}

	handleCORS := cors.New(cors.Options{
		AllowedOrigins:   []string{cfg.AllowedOrigin},
		AllowedMethods:   []string{"POST", "PUT", "GET", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"*"},
		AllowCredentials: true,
		{{- if .Debug}}
			// Enable Debugging for testing, consider disabling in production
			Debug: true,
		{{- end}}
	}).Handler
	
	server.SetHandler(handleCORS(globalMiddlewares(api.Serve(middlewares))))

	return server, nil
}

func healthCheck(params operations.HealthCheckParams, profile interface{}) middleware.Responder {
	return operations.NewHealthCheckOK().WithPayload(&operations.HealthCheckOKBody{Ok: true})
}

func appAccessManager(am *models.AccessManager) *app.AccessManager {
	return &app.AccessManager{
		User:          am.User,
		Group:         am.Group,
		Read:          am.Read,
		Write:         am.Write,
		Delete:        am.Delete,
		Add:           am.Add,
		AccessManager: am.AccessManager,
	}
}

{{- if .HaveListMethod}}
	func appFilters(apiFP []*models.FilterParams) []*app.Filter {
		appF := []*app.Filter{}
		for _, fp := range apiFP {
			appF = append(appF, &app.Filter{
				Include: fp.Include,
				Key:     fp.Key,
				Value:   fp.Value,
			})
		}
		return appF
	}
{{- end}}

{{- if .HaveDateTime}}
	func fromDateTimesArray(dts []strfmt.DateTime) (dates []string) {
		for _, date := range dts {
			dates = append(dates, date.String())
		}
		return
	}

	func toDateTimesArray(dates []string) (dts []strfmt.DateTime) {
		for _, date := range dates {
			dts = append(dts, toDateTime(date))
		}
		return
	}

	func toDateTime(date string) (dt strfmt.DateTime) {
		if date == "" {
			return
		}
		dt.Scan(date)
		return
	}
{{end}}

{{- if .HaveEmail}}
	func fromEmailsArray(es []strfmt.Email) (emails []string) {
		for _, email := range es {
			emails = append(emails, email.String())
		}
		return
	}

	func toEmailsArray(emails []string) (es []strfmt.Email) {
		for _, email := range emails {
			es = append(es, strfmt.Email(email))
		}
		return
	}
{{end}}

{{- if .HaveFloatArr}}
	func float64to32Array(floats64 []float64) (floats32 []float32) {
		for _, f64 := range floats64 {
			floats32 = append(floats32, float32(f64))
		}
		return
	}


	func float32to64Array(floats32 []float32) (floats64 []float64) {
		for _, f32 := range floats32 {
			floats64 = append(floats64, float64(f32))
		}
		return
	}
{{end}}

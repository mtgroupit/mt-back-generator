// Code generated by mtgroup-generator.
package api

import (
	"{{.Name}}/internal/api/restapi/models"
	"{{.Name}}/internal/api/restapi/restapi"
	"{{.Name}}/internal/api/restapi/restapi/operations"
	"{{.Name}}/internal/app"

	"github.com/go-openapi/loads"
	"github.com/go-openapi/runtime/middleware" 
	{{if or  .HaveDateTime .HaveEmail}}"github.com/go-openapi/strfmt"{{end}}
	"github.com/pkg/errors"
	"github.com/powerman/structlog"
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

type Config struct {
	Host     string
	Port     int
	BasePath string
}

type service struct {
	app app.App
}

var log = structlog.New()

func NewServer(appl app.App, cfg Config) (*restapi.Server, error) {
	svc := &service{
		app: appl,
	}

	swaggerSpec, err := loads.Embedded(restapi.SwaggerJSON, restapi.FlatSwaggerJSON)
	if err != nil {
		return nil, errors.Wrap(err, "failed to load embedded swagger spec")
	}
	if cfg.BasePath == "" {
		cfg.BasePath = swaggerSpec.BasePath()
	}
	swaggerSpec.Spec().BasePath = cfg.BasePath

	api := operations.New{{.Name}}API(swaggerSpec)

	api.Logger = structlog.New(structlog.KeyUnit, "swagger").Printf

    {{range $modelName, $model := $.Models}}{{range $i, $method := $model.Methods}}
	api.{{$method}}{{$model.TitleName}}Handler = operations.{{$method}}{{$model.TitleName}}HandlerFunc(svc.{{$method}}{{$modelName}}) {{end}}{{end}}
    {{range $modelName, $model := $.Models}}{{range $function, $_ := $.Functions}}
	api.{{$modelName}}{{$function}}Handler = operations.{{$modelName}}{{$function}}HandlerFunc(svc.{{$function}}{{$modelName}}) {{end}}{{end}}

	server := restapi.NewServer(api)
	server.Host = cfg.Host
	server.Port = cfg.Port

	return server, nil
}

{{range $modelName, $model := $.Models}}{{range $i, $method := $model.Methods}}
func (svc *service) {{$method}}{{$modelName}}(params operations.{{$method}}{{$model.TitleName}}Params) middleware.Responder {
	{{if eq $method "Get"}}c, err := svc.app.{{$method}}{{$modelName}}(params.Body.ID)
	if err != nil {
		log.Err("{{$method}}{{$modelName}} error", err)
	} else {
		log.Info("{{$method}}{{$modelName}} ok", "id", params.Body.ID)
	}
	return operations.New{{$method}}{{$model.TitleName}}OK().WithPayload(api{{$modelName}}(*c)){{end}}
	{{if eq $method "Add"}}err := svc.app.{{$method}}{{$modelName}}(app{{$modelName}}(params.Body, true))
	if err != nil {
		log.Err("{{$method}}{{$modelName}} error", err)
	} else {
		log.Info("{{$method}}{{$modelName}} ok")
	}
	return operations.New{{$method}}{{$model.TitleName}}Created(){{end}}
	{{if eq $method "Delete"}}err := svc.app.{{$method}}{{$modelName}}(params.Body.ID)
	if err != nil {
		log.Err("{{$method}}{{$modelName}} error", err)
	} else {
		log.Info("{{$method}}{{$modelName}} ok", "id", params.Body.ID)
	}
	return operations.New{{$method}}{{$model.TitleName}}NoContent(){{end}}
	{{if eq $method "Edit"}}err := svc.app.{{$method}}{{$modelName}}(params.Body.ID, app{{$modelName}}(params.Body, true))
	if err != nil {
		log.Err("{{$method}}{{$modelName}} error", err)
	} else {
		log.Info("{{$method}}{{$modelName}} ok", "id", params.Body.ID)
	}
	return operations.New{{$method}}{{$model.TitleName}}OK(){{end}}
	{{if  or (eq $method "List") (IsCustomList $method)}}c, err := svc.app.{{$method}}{{$modelName}}(*params.Body.Offset, *params.Body.Limit, appFilters(params.Body.Filters))
	if err != nil {
		log.Err("{{$method}}{{$modelName}} error", err)
	} else {
		log.Info("{{$method}}{{$modelName}} ok")
	}
	return operations.New{{$method}}{{$model.TitleName}}OK().WithPayload(api{{$modelName}}s(c)){{end}}
	{{if and (ne $method "Get") (ne $method "Add") (ne $method "Delete") (ne $method "Edit") (ne $method "List") (not (IsCustomList $method))}}
	return operations.New{{$method}}{{$model.TitleName}}OK(){{end}}
}
{{end}}{{end}}
{{range $modelName, $model := $.Models}}{{range $functionName, $function := $.Functions}}
func (svc *service) {{$functionName}}{{$modelName}}(params operations.{{$modelName}}{{$functionName}}Params) middleware.Responder {
	{{$function.OutStr}}, err := svc.app.{{$functionName}}{{$modelName}}({{$function.InStrParams}})
	if err != nil {
		log.Err("{{$functionName}}{{$modelName}} error", err)
	} else {
		log.Info("{{$functionName}}{{$modelName}} ok")
	}
	return operations.New{{$modelName}}{{$functionName}}OK(){{if $function.HaveOut}}.WithPayload(&models.{{$functionName}}Params{
		{{range $name, $_ := $function.In}}
		{{$name}}: params.Body.{{$name}},{{end}}
		{{range $name, $_ := $function.Out}}
		{{$name}}: {{$name}},{{end}}
	}){{end}}
}
{{end}}{{end}}
{{range $modelName, $model := $.Models}}
func api{{$modelName}}(a app.{{$modelName}}) *models.{{$modelName}} {
	return &models.{{$modelName}}{ {{range $name, $options := $model.Columns}}
		{{$options.TitleName}}: {{if $options.IsStruct}}api{{$options.GoType}}{{if $options.IsArray}}s({{else}}(*{{end}}a.{{$options.TitleName}}){{else}}{{if eq $options.Format "date-time"}}toDateTime(a.{{$options.TitleName}}){{else}}{{if eq $options.Format "email"}}strfmt.Email(a.{{$options.TitleName}}){{else}}a.{{$options.TitleName}}{{end}}{{end}}{{end}},{{end}}
	}
}

func api{{$modelName}}s(apps []*app.{{$modelName}}) []*models.{{$modelName}} {
	apis := []*models.{{$modelName}}{}
	for i := range apps {
		apis = append(apis, api{{$modelName}}(*apps[i]))
	}
	return apis
}

func app{{$modelName}}(a *models.{{$modelName}}, withStructs bool) *app.{{$modelName}} {
	if withStructs {
		return &app.{{$modelName}}{ {{range $name, $options := $model.Columns}}
			{{$options.TitleName}}: {{if $options.IsStruct}}app{{$options.GoType}}{{if $options.IsArray}}s{{end}}(a.{{$options.TitleName}}, false){{else}}a.{{$options.TitleName}}{{if or (eq $options.Format "date-time") (eq $options.Format "email")}}.String(){{end}}{{end}},{{end}}
		}
	}
	return &app.{{$modelName}}{ {{range $name, $options := $model.Columns}}{{if not $options.IsStruct}}
		{{$options.TitleName}}: a.{{$options.TitleName}}{{if or (eq $options.Format "date-time") (eq $options.Format "email")}}.String(){{end}},{{end}}{{end}}
	}
}

func app{{$modelName}}s(apis []*models.{{$modelName}}, withStructs bool) []*app.{{$modelName}} {
	apps := []*app.{{$modelName}}{}
	for i := range apis {
		apps = append(apps, app{{$modelName}}(apis[i], withStructs))
	}
	return apps
}{{end}}
{{if .HaveListMethod}}
func appFilters(apiFP []*models.FilterParams) []*app.Filter {
	appF := []*app.Filter{}
	for _, fp := range apiFP {
		appF = append(appF, &app.Filter{
			Include: fp.Include,
			Key:     fp.Key,
			Value:   fp.Value,
		})
	}
	return appF
}{{end}}
{{if .HaveDateTime}}
func toDateTime(date string) (dt strfmt.DateTime) {
	dt.Scan(date)
	return dt
}{{end}}

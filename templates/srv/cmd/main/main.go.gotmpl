// Code generated by mtgroup-generator.
package main

import (
	"context"
	"crypto/tls"
	"flag"
	"fmt"
	"time"

	"{{.Module}}/internal/api"
	"{{.Module}}/internal/app"
	"{{.Module}}/internal/dal"
	"{{.Module}}/internal/def"

	extauthapi "{{.AuthSrv}}"
	"github.com/powerman/pqx"
	"github.com/powerman/structlog"
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

const (
	connectTimeout = 3 * time.Second

	ExtauthEndpointFlag = "extauth.endpoint"
)

var (
	testRepo     *dal.Repo
	testAppl     app.App

	log = structlog.New()
	cfg struct {
		logLevel string
		gooseDir string
		db       pqx.Config
		api      api.Config
		extauthEndpoint string{{if .Debug}}
		resetDB   bool{{end}}
	}
)

func init() {
	cfg.db.SSLMode = pqx.SSLRequire
	flag.StringVar(&cfg.logLevel, "log.level", "debug", "log `level` (debug|info|warn|err)")
	flag.StringVar(&cfg.gooseDir, "goose.dir", def.GooseDir, "goose migrations `dir`")
	flag.StringVar(&cfg.db.Host, "db.host", def.DBHost, "PostgreSQL `host`")
	flag.IntVar(&cfg.db.Port, "db.port", def.DBPort, "PostgreSQL `port`")
	flag.StringVar(&cfg.db.User, "db.user", def.DBUser, "PostgreSQL `user`")
	flag.StringVar(&cfg.db.Pass, "db.pass", def.DBPass, "PostgreSQL `pass`")
	flag.StringVar(&cfg.db.DBName, "db.name", def.DBName, "PostgreSQL `dbname`")

	flag.StringVar(&cfg.api.Host, "api.host", def.APIHost, "serve API on `host`")
	flag.IntVar(&cfg.api.Port, "api.port", def.APIPort, "serve API on `port` (>0)")
	flag.StringVar(&cfg.api.BasePath, "api.basepath", def.APIBasePath, "serve API on `path`")
	flag.StringVar(&cfg.api.AllowedOrigin, "api.allow-origin", def.CORSAllowedOrigin, "frontend url")

	flag.StringVar(&cfg.extauthEndpoint, ExtauthEndpointFlag, def.ExtauthEndpoint, "extauth service `endpoint`"){{if .Debug}}

	flag.BoolVar(&cfg.resetDB, "db.reset", def.ResetDB, "reset database if true"){{end}}
}

func main() {
	flag.Parse()
	structlog.DefaultLogger.SetLogLevel(structlog.ParseLevel(cfg.logLevel))

	var err error
	errc := make(chan error)
	go runServe(errc)
	err = <-errc
	if err != nil {
		log.Fatal(err)
	}
}

func connect() (app.App,{{if .HaveCustomMethod}} app.Customs,{{end}} *extauthapi.Client, error) {
	ctx, cancel := context.WithTimeout(context.Background(), connectTimeout)
	defer cancel()

	extAuthSvc, err := extauthapi.NewClient(cfg.extauthEndpoint, &tls.Config{InsecureSkipVerify: true}, false)
	if err != nil {
		return nil,{{if .HaveCustomMethod}} nil,{{end}} nil, fmt.Errorf("extauthapi: %v. Error can be if flag '%s' or environment variable '%s' is not set", err, ExtauthEndpointFlag, def.ExtauthEndpointEnvName)
	}

	r, {{if .HaveCustomMethod}}cr, {{end}} err := dal.New(ctx, cfg.db, cfg.gooseDir{{if .Debug}}, cfg.resetDB{{end}})
	if err != nil {
		return nil,{{if .HaveCustomMethod}} nil,{{end}} nil, err
	}
	
	app{{if .HaveCustomMethod}}, cust{{end}} := app.New(r{{if .HaveCustomMethod}}, cr{{end}})
	return app{{if .HaveCustomMethod}}, cust{{end}}, extAuthSvc, nil
}

func runServe(errc chan<- error) {
	log.Info("server started")
	defer log.Info("server finished")

	appl,{{if .HaveCustomMethod}} cust,{{end}} extAuthSvc, err := connect()
	if err != nil {
		errc <- err
		return
	}

	srv, err := api.NewServer(appl,{{if .HaveCustomMethod}} cust,{{end}} extAuthSvc, cfg.api)
	if err != nil {
		errc <- fmt.Errorf("api: %v", err)
		return
	}

	errc <- srv.Serve()
}

// Code generated by mtgroup-generator.
package main

import (
	"context"
	"crypto/tls"
	"flag"
	"fmt"
	"time"

	"{{.Module}}/internal/api"
	"{{.Module}}/internal/app"
	"{{.Module}}/internal/authorization"
	"{{.Module}}/internal/dal"
	"{{.Module}}/internal/def"
	{{- if .Notifier}}
		"{{.Module}}/internal/mailer"
	{{- end}}

	extauthapi "{{.AuthSrv}}"
	"github.com/powerman/pqx"
	"github.com/powerman/structlog"
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

const (
	connectTimeout = 3 * time.Second

	ExtauthEndpointFlag = "extauth.endpoint"
)

var (
	testRepo     *dal.Repo
	testAppl     app.App

	log = structlog.New()
	cfg struct {
		logLevel        string
		gooseDir        string
		db              pqx.Config
		api             api.Config
		{{- if .Notifier}}
		mailer          mailer.Config
		{{- end}}
		extauthEndpoint string
		{{- if .Debug}}
		resetDB         bool
		{{- end}}
	}
)

func init() {
	var dbSSLModeRequire bool

	flag.BoolVar(&dbSSLModeRequire, "db.ssl-mode-is-req", def.DBSSLModeIsReq, "PostgreSQL SSL mode")

	if dbSSLModeRequire {
		cfg.db.SSLMode = pqx.SSLRequire
	} else {
		cfg.db.SSLMode = pqx.SSLDisable
	}
	flag.StringVar(&cfg.logLevel, "log.level", "debug", "log `level` (debug|info|warn|err)")

	flag.StringVar(&cfg.gooseDir, "goose.dir", def.GooseDir, "goose migrations `dir`")
	flag.StringVar(&cfg.db.Host, "db.host", def.DBHost, "PostgreSQL `host`")
	flag.IntVar(&cfg.db.Port, "db.port", def.DBPort, "PostgreSQL `port`")
	flag.StringVar(&cfg.db.User, "db.user", def.DBUser, "PostgreSQL `user`")
	flag.StringVar(&cfg.db.Pass, "db.pass", def.DBPass, "PostgreSQL `pass`")
	flag.StringVar(&cfg.db.DBName, "db.name", def.DBName, "PostgreSQL `dbname`")
	{{- if .Debug}}
		flag.BoolVar(&cfg.resetDB, "db.reset", def.ResetDB, "reset database if true")
	{{end}}

	flag.StringVar(&cfg.api.Host, "api.host", def.APIHost, "serve API on `host`")
	flag.IntVar(&cfg.api.Port, "api.port", def.APIPort, "serve API on `port` (>0)")
	flag.StringVar(&cfg.api.BasePath, "api.basepath", def.APIBasePath, "serve API on `path`")
	flag.StringVar(&cfg.api.AllowedOrigins, "api.allow-origins", def.CORSAllowedOrigins, "frontend url")

	flag.StringVar(&cfg.extauthEndpoint, ExtauthEndpointFlag, def.ExtauthEndpoint, "extauth service `endpoint`")
	{{if .Notifier}}
		flag.StringVar(&cfg.mailer.From, "mailer.from", def.MailerFrom, "email from")
		flag.StringVar(&cfg.mailer.NameFrom, "mailer.from-name", def.MailerFromName, "email from name")
		flag.StringVar(&cfg.mailer.Pass, "mailer.pass", def.MailerPass, "email sender apikey")
	{{end}}
}

func main() {
	flag.Parse()
	structlog.DefaultLogger.SetLogLevel(structlog.ParseLevel(cfg.logLevel))

	var err error
	errc := make(chan error)
	go runServe(errc)
	err = <-errc
	if err != nil {
		log.Fatal(err)
	}
}

func connect() (app.App,{{if .HaveCustomMethod}} app.Customs,{{end}} *extauthapi.Client, error) {
	ctx, cancel := context.WithTimeout(context.Background(), connectTimeout)
	defer cancel()

	extAuthSvc, err := extauthapi.NewClient(cfg.extauthEndpoint, &tls.Config{InsecureSkipVerify: true}, false)
	if err != nil {
		return nil,{{if .HaveCustomMethod}} nil,{{end}} nil, fmt.Errorf("extauthapi: %v. Error can be if flag '%s' or environment variable '%s' is not set", err, ExtauthEndpointFlag, def.ExtauthEndpointEnvName)
	}

	r, {{if .HaveCustomMethod}}cr, {{end}} err := dal.New(ctx, cfg.db, cfg.gooseDir{{if .Debug}}, cfg.resetDB{{end}})
	if err != nil {
		return nil,{{if .HaveCustomMethod}} nil,{{end}} nil, err
	}

	rulesSet := authorization.NewRulesSet()
	{{if .Notifier}}
	m := mailer.New(log, cfg.mailer)
	{{end}}
	app{{if .HaveCustomMethod}}, cust{{end}} := app.New(r{{if .HaveCustomMethod}}, cr{{end}}, rulesSet{{if .Notifier}}, m{{end}})
	return app{{if .HaveCustomMethod}}, cust{{end}}, extAuthSvc, nil
}

func runServe(errc chan<- error) {
	log.Info("server started")
	defer log.Info("server finished")

	appl,{{if .HaveCustomMethod}} cust,{{end}} extAuthSvc, err := connect()
	if err != nil {
		errc <- err
		return
	}

	srv, err := api.NewServer(appl,{{if .HaveCustomMethod}} cust,{{end}} extAuthSvc, cfg.api)
	if err != nil {
		errc <- fmt.Errorf("api: %v", err)
		return
	}

	errc <- srv.Serve()
}

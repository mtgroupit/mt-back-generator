// Code generated by mtgroup-generator.
package migration

import (
	"context"
	"database/sql"
	"strings"
	"sync"
	"time"
	"path/filepath"
	"io/ioutil"
	"os"

	_ "github.com/lib/pq" // Driver.
	"github.com/pkg/errors"
	"github.com/powerman/must"
	_ "github.com/powerman/narada4d/protocol/goose-postgres" // Driver.
	"github.com/powerman/pqx"
	"github.com/powerman/structlog"
	"github.com/pressly/goose"
)

// Make sure not to overwrite this file after you generated it because all your edits would be lost!

const (
	dbTimeout     = 150 * time.Second
	dbIdleTimeout = 150 * time.Second
)

var (
	log = structlog.New().SetDefaultKeyvals(structlog.KeyUnit, "migrate")
	gooseMu sync.Mutex
)

func connect(ctx context.Context, cfg pqx.Config) (*sql.DB, error) {
	goose.SetLogger(structlog.New().
		SetDefaultKeyvals(structlog.KeyUnit, "goose").
		SetKeysFormat(map[string]string{structlog.KeyMessage: " %[2]s"}))
	must.NoErr(goose.SetDialect("postgres"))

	cfg.DefaultTransactionIsolation = sql.LevelDefault
	cfg.StatementTimeout = dbTimeout
	cfg.LockTimeout = dbTimeout
	cfg.IdleInTransactionSessionTimeout = dbIdleTimeout

	db, err := sql.Open("postgres", cfg.FormatDSN())
	if err != nil {
		return nil, err
	}

	err = db.PingContext(ctx)
	for err != nil {
		nextErr := db.PingContext(ctx)
		if nextErr == context.DeadlineExceeded {
			log.WarnIfFail(db.Close)
			return nil, errors.Wrap(err, "connect to postgres")
		}
		err = nextErr
	}

	return db, nil
}

func Up(ctx context.Context, dir string, cfg pqx.Config) error {
	gooseMu.Lock()
	defer gooseMu.Unlock()

	db, err := connect(ctx, cfg)
	if err != nil {
		return err
	}
	defer log.WarnIfFail(db.Close)

	err = goose.Up(db, dir)
	if err != nil {
		return errors.Wrapf(err, "failed migration")
	}

	return nil
}

// ResetAll rolls back all migrations and applies all available migrations.
func ResetAll(ctx context.Context, dir string, cfg pqx.Config) error {
	gooseMu.Lock()
	defer gooseMu.Unlock()

	db, err := connect(ctx, cfg)
	if err != nil {
		log.Warn("connect!")
		return err
	}
	defer log.WarnIfFail(db.Close)

	err = goose.DownTo(db, dir, 0)
	if err != nil {
		return errors.Wrapf(err, "failed migration down")
	}

	return nil
}

// Run executes goose command. It also enforce "fix" after "create".
func Run(ctx context.Context, dir string, command string, cfg pqx.Config) error {
	gooseMu.Lock()
	defer gooseMu.Unlock()

	db, err := connect(ctx, cfg)
	if err != nil {
		return err
	}
	defer log.WarnIfFail(db.Close)

	cmdArgs := strings.Fields(command)
	cmd, args := cmdArgs[0], cmdArgs[1:]
	err = goose.Run(cmd, db, dir, args...)
	if err == nil && cmd == "create" {
		err = goose.Run("fix", db, dir)
	}
	return errors.Wrapf(err, "failed to run goose %q", command)
}

func DBVersion(ctx context.Context, cfg pqx.Config) (int64, error) {
	db, err := connect(ctx, cfg)
	if err != nil {
		return 0, err
	}
	defer log.WarnIfFail(db.Close)

	version, err := goose.GetDBVersion(db)
	return version, err
}

func InitDBSchema(ctx context.Context, zeroMigrationsDir string, cfg pqx.Config) error {
	db, err := connect(ctx, cfg)
	if err != nil {
		return err
	}
	defer log.WarnIfFail(db.Close)

	err = filepath.Walk(zeroMigrationsDir, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }
		if strings.HasSuffix(info.Name(), ".sql") {
        	return applyZeroMigrationFile(db, path)
		}
		return nil
    })
	return err
}

func applyZeroMigrationFile(db *sql.DB, file string) error {
	data, err := ioutil.ReadFile(file)
    if err != nil {
        return err
    }
	_, err = db.Exec(string(data))
	return err
}
